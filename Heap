Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required.

fun minMeetingRooms(intervals: Array<IntArray>): Int {

//	sort the intervals based on start time
    intervals.sortBy { it[0] }
 
// 	min heap to store end times of meetings
    val heap = PriorityQueue<Int>() 

    for (interval in intervals) {
        if (heap.isNotEmpty() && interval[0] >= heap.peek()) {
//	no extra meeting room needed as end time is less than next one’s start time
// 	remove the meeting that ends earliest
            heap.poll() 
        }
// 	add the end time of the current meeting to the heap
        heap.offer(interval[1]) 
    }
    return heap.size
}



Heap sort

class Solution {
    fun sortArray(nums: IntArray): IntArray {
        heapSort(nums)

        return nums
    }

    fun heapSort(numsArray: IntArray){
//  start from the middle and heapify each subtree with ith node as root. here we are ignoring the leaf nodes
        for(nodeIndex in numsArray.size / 2 - 1 downTo 0){
            heapify(numsArray, numsArray.size, nodeIndex)
        }

        for(counter in numsArray.size - 1 downTo 1){
//  place the last element on the top by swapping violating the heap rule            
            val temp = numsArray[counter]
            numsArray[counter] = numsArray[0]
            numsArray[0] = temp

//  heapify the root node as it might have violated the rule. this will place the new root node at the right place
            heapify(numsArray, counter, 0)            
        }
    }

    fun heapify(numsArray: IntArray, heapSize: Int, nodeIndex: Int){
//  in a heap parent node is always larger than the child node 

        var largestNodeIndex = nodeIndex
        val leftChildIndex = nodeIndex * 2 + 1
        val rightChildIndex = nodeIndex * 2 + 2

        if(leftChildIndex < heapSize
            && numsArray[leftChildIndex] > numsArray[largestNodeIndex]){
                largestNodeIndex = leftChildIndex
        }
        if(rightChildIndex < heapSize
            && numsArray[rightChildIndex] > numsArray[largestNodeIndex]){
                largestNodeIndex = rightChildIndex
        }
//   now we have the index of largest child

        if(largestNodeIndex != nodeIndex){
//  largest node is at the wrong position and hence the kids too
            val temp = numsArray[nodeIndex]  
            numsArray[nodeIndex] = numsArray[largestNodeIndex]  
            numsArray[largestNodeIndex] = temp       

//  heapify the kids also
            heapify(numsArray, heapSize, largestNodeIndex)
        }
    }
}



Top K Frequent Elements

class Solution {
    fun topKFrequent(nums: IntArray, k: Int): IntArray {
        if(nums.size == k){
            return nums
        }

        val numCountMap = mutableMapOf<Int, Int>()
        for(num in nums){
            numCountMap.put(num, numCountMap.getOrDefault(num, 0) + 1)
        }

//  keep a min heap so we can poll the least frequent element easily
        val minHeap = PriorityQueue<Int>{ 
                            a, b -> numCountMap[a]!!.toInt().compareTo(numCountMap[b]!!.toInt()) 
                      }
        
        for((num, count) in numCountMap){
            minHeap.add(num)
            if(minHeap.size > k){
                minHeap.poll()
            }
        }

        val topKNums = IntArray(k)
        for(counter in k - 1 downTo 0){
//  poll gives the least frequent element
            topKNums[counter] = minHeap.poll()
        }

        return topKNums
    }
}



Remove Stones to Minimize the Total - You are given a 0-indexed integer array piles, where piles[i] represents the number of stones in the ith pile, and an integer k. You should apply the following operation exactly k times:

Choose any piles[i] and remove floor(piles[i] / 2) stones from it.
Notice that you can apply the operation on the same pile more than once.

Return the minimum possible total number of stones remaining after applying the k operations.

class Solution {
    fun minStoneSum(piles: IntArray, k: Int): Int {
        val maxHeap = PriorityQueue<Int>({ a, b -> b - a })
//  heap is important because we want to find the pile with most stones after each operation

        for(stoneNum in piles){
//  max pile of stones will be on top of heap            
            maxHeap.add(stoneNum)
        }

        for(counter in 0 until k){
//  remove stones for k times            
            val currPile = maxHeap.remove()
//  remove from the highest number to optimize            
            val removeStonesNum = currPile / 2
//  keep the left stones back in the heap for this pile to be placed at right index
            maxHeap.add(currPile - removeStonesNum)
        }

        var leftStonesNum = 0
        for(stoneNum in maxHeap){
            leftStonesNum += stoneNum
        }

        return leftStonesNum
    }
}



Kth largest element in an array - Given an integer array nums and an integer k, return the kth largest element in the array.

Note that it is the kth largest element in the sorted order, not the kth distinct element.

Can you solve it without sorting?

/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
const findKthLargest = (nums, k) => {
    const minHeap = new MinHeap()
    for (const num of nums) {
        minHeap.push(num)
    }

    for (let i = 0; i < nums.length; i++) {
        const element = minHeap.pop()
        if (nums.length - i === k) {
            return element
        }
    }

    return -1
};

class MinHeap {
    constructor() {
        this.heap = [];
    }

    push(val) {
        this.heap.push(val);
        this.heapifyUp();
    }

    pop() {
        if (this.isEmpty()) {
            return null;
        }

        const root = this.heap[0];
        const lastNode = this.heap.pop();

        if (this.heap.length > 0) {
            this.heap[0] = lastNode;
            this.heapifyDown();
        }

        return root;
    }

    isEmpty() {
        return this.heap.length === 0;
    }

    heapifyUp() {
        let index = this.heap.length - 1;

        while (index > 0) {
            const parentIndex = Math.floor((index - 1) / 2);

            if (this.heap[index] < this.heap[parentIndex]) {
                this.swap(index, parentIndex);
                index = parentIndex;
            } else {
                break;
            }
        }
    }

    heapifyDown() {
        let index = 0;
        const length = this.heap.length;

        while (true) {
            const leftChildIndex = 2 * index + 1;
            const rightChildIndex = 2 * index + 2;
            let smallestChildIndex = index;

            if (leftChildIndex < length && this.heap[leftChildIndex] < this.heap[smallestChildIndex]) {
                smallestChildIndex = leftChildIndex;
            }

            if (rightChildIndex < length && this.heap[rightChildIndex] < this.heap[smallestChildIndex]) {
                smallestChildIndex = rightChildIndex;
            }

            if (smallestChildIndex !== index) {
                this.swap(index, smallestChildIndex);
                index = smallestChildIndex;
            } else {
                break;
            }
        }
    }

    swap(i, j) {
        const temp = this.heap[i];
        this.heap[i] = this.heap[j];
        this.heap[j] = temp;
    }
}



Meeting rooms - You are given an integer n. There are n rooms numbered from 0 to n - 1.

You are given a 2D integer array meetings where meetings[i] = [starti, endi] means that a meeting will be held during the half-closed time interval [starti, endi). All the values of starti are unique.

Meetings are allocated to rooms in the following manner:
Each meeting will take place in the unused room with the lowest number.
If there are no available rooms, the meeting will be delayed until a room becomes free. The delayed meeting should have the same duration as the original meeting.
When a room becomes unused, meetings that have an earlier original start time should be given the room.

Return the number of the room that held the most meetings. If there are multiple rooms, return the room with the lowest number.

A half-closed interval [a, b) is the interval between a and b including a and not including b.



Maximum score from removing stones - You are playing a solitaire game with three piles of stones of sizes a​​​​​​, b,​​​​​​ and c​​​​​​ respectively. Each turn you choose two different non-empty piles, take one stone from each, and add 1 point to your score. The game stops when there are fewer than two non-empty piles (meaning there are no more available moves).

Given three integers a​​​​​, b,​​​​​ and c​​​​​, return the maximum score you can get.

/**
 * @param {number} a
 * @param {number} b
 * @param {number} c
 * @return {number}
 */
const maximumScore = (a, b, c) => {

    //  use max heap to track sizes of piles
    //  take two largest piles and get a score as per condition
    //  then put the piles back

    const maxHeap = new MaxHeap()
    maxHeap.push(a)
    maxHeap.push(b)
    maxHeap.push(c)

    let score = 0

    while (maxHeap.heap.length >= 2) {
        const pile1 = maxHeap.pop()
        const pile2 = maxHeap.pop()

        if (pile1 > 1) {
            maxHeap.push(pile1 - 1)
        }
        if (pile2 > 1) {
            maxHeap.push(pile2 - 1)
        }

        score++
    }

    return score
};

class MaxHeap {
    constructor() {
        this.heap = []
    }

    push(value) {
        this.heap.push(value)
        this.heapifyUp()
    }

    isEmpty() {
        return this.heap.length === 0
    }

    pop() {
        if (this.isEmpty()) {
            return null
        }

        const root = this.heap[0]
        const last = this.heap.pop()

        if (!this.isEmpty()) {
            this.heap[0] = last
            this.heapifyDown()
        }

        return root
    }

    heapifyUp() {
        let currentIdx = this.heap.length - 1;

        while (currentIdx > 0) {
            const parentIdx = Math.floor((currentIdx - 1) / 2);

            if (this.heap[currentIdx] > this.heap[parentIdx]) {
                [this.heap[currentIdx], this.heap[parentIdx]] = [
                    this.heap[parentIdx],
                    this.heap[currentIdx],
                ];
                currentIdx = parentIdx;
            } else {
                break;
            }
        }
    }

    heapifyDown() {
        let currentIdx = 0;

        while (true) {
            const leftChildIdx = 2 * currentIdx + 1;
            const rightChildIdx = 2 * currentIdx + 2;
            let swapIdx = null;

            if (leftChildIdx < this.heap.length && this.heap[leftChildIdx] > this.heap[currentIdx]) {
                swapIdx = leftChildIdx;
            }

            if (rightChildIdx < this.heap.length && this.heap[rightChildIdx] > this.heap[currentIdx]) {
                if (swapIdx === null || this.heap[rightChildIdx] > this.heap[swapIdx]) {
                    swapIdx = rightChildIdx;
                }
            }

            if (swapIdx === null) {
                break;
            }

            [this.heap[currentIdx], this.heap[swapIdx]] = [this.heap[swapIdx], this.heap[currentIdx]];
            currentIdx = swapIdx;
        }
    }
}



Kth largest integer in an array - You are given an array of strings nums and an integer k. Each string in nums represents an integer without leading zeros.

Return the string that represents the kth largest integer in nums.

/**
 * @param {string[]} nums
 * @param {number} k
 * @return {string}
 */
const kthLargestNumber = (nums, k) => {
    const maxHeap = new MaxPriorityQueue({ compare: (a, b) => { return b - a } })

    nums.forEach(num => maxHeap.enqueue(BigInt(num)))

    while (k > 1) {
        maxHeap.dequeue()
        k--
    }
    return maxHeap.front().toString()
};

