/* Generate Parentheses - Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. */

const generateParenthesis = (n) => {
    const res = []

    //  l: left remaining, r: right remaining
    const backTrack = (l, r, currStr) => {
        if (currStr.length === 2 * n) {
            res.push(currStr)
            return
        }

        //  we still have left brackets to place
        if (l < n) {
            backTrack(l + 1, r, currStr + '(')
        }
        //  close the left bracket
        if (r < l) {
            backTrack(l, r + 1, currStr + ')')
        }
    }

    backTrack(0, 0, '')

    return res
};


/* Letter Combinations of a Phone Number - Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.
 */
/**
 * @param {string} digits
 * @return {string[]}
 */
const letterCombinations = (digits) => {
    const letterMap = {
        '2': 'abc',
        '3': 'def',
        '4': 'ghi',
        '5': 'jkl',
        '6': 'mno',
        '7': 'pqrs',
        '8': 'tuv',
        '9': 'wxyz'
    }
    const list = []

    if (digits.length > 0) {
        findCombinations(0, '', digits, list, letterMap)
    }

    return list
};

const findCombinations = (currCharIndex, currString, digits, list, letterMap) => {
    if (currCharIndex == digits.length) {
        list.push(currString)
    } else {
        const currDigit = digits[currCharIndex]
        const currChars = letterMap[currDigit]
        for (const c of currChars) {
            findCombinations(currCharIndex + 1, currString + c, digits, list, letterMap)
        }
    }
}



All Paths From Source to Target - Given a directed acyclic graph(DAG) of n nodes labeled from 0 to n - 1, find all possible paths from node 0 to node n - 1 and return them in any order.

The graph is given as follows: graph[i] is a list of all nodes you can visit from node i(i.e., there is a directed edge from node i to node graph[i][j]).

const allPathsSourceTarget = (graph) => {
    //  we will solve using backtracking
    //  srcIndex = 0, targetIndex = graphsize - 1

    const src = 0
    const target = graph.length - 1

    const allPaths = []

    const dfs = (startNode, path, visitedMap) => {
        path.push(startNode)
        if (startNode === target) {
            //  found the target
            allPaths.push([...path])
            return
        }
        //  explore all the adjacent nodes
        for (let neighbour of graph[startNode]) {
            if (!visitedMap[neighbour]) {
                visitedMap[neighbour] = true
                //  call dfs with neighbour as a new start node
                dfs(neighbour, path, visitedMap)
                //  unmark for the other path
                visitedMap[neighbour] = false
                //  remove this neighbour also
                path.pop()
            }
        }
    }

    dfs(src, [], {})
    return allPaths
};

/* Non-decreasing Subsequences - Given an integer array nums, return all the different possible non-decreasing subsequences of the given array with at least two elements. You may return the answer in any order.
 */
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
const findSubsequences = (nums) => {
    const res = []
    const map = {}
    const iterate = (index, temp) => {
        if (map[temp]) return;
        if (temp.length >= 2) {
            res.push(temp)
        }
        for (let i = index; i < nums.length; i++) {
            if (temp[temp.length - 1] > nums[i]) {
                continue;
            }
            map[temp] = true;
            iterate(i + 1, [...temp, nums[i]])
        }
    }
    iterate(0, [])
    return res;
};

/* Permutations - Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.
 */
const permute = (nums) => {
    const res = []

    const backTrack = (currArr, nums) => {
        if (nums.length === 0) {
            res.push(currArr)
            return
        }
        for (let i = 0; i < nums.length; i++) {
            //  add ith index num to currArr and remove from nums for further iteration
            backTrack([...currArr, nums[i]], [...nums.slice(0, i), ...nums.slice(i + 1)], res)
        }
    }

    backTrack([], nums)
    return res
};

/* Combination Sum - Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.

Each number in candidates may only be used once in the combination.

Note: The solution set must not contain duplicate combinations.
 */
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
const combinationSum = (candidates, target) => {
    const res = []

    const backTrack = (currIndex, currArr, targetLeft) => {
        if (0 === targetLeft) {
            res.push([...currArr])
            return
        }
        if (0 > targetLeft) {
            return
        }
        for (let i = currIndex; i < candidates.length; i++) {
            //  same item can be considered multiple times
            currArr.push(candidates[i])
            backTrack(i, currArr, targetLeft - candidates[i])
            //  remove for next iteration
            currArr.pop()
        }
    }
    backTrack(0, [], target)

    return res
};


/* Power set - Given an integer array nums of unique elements, return all possible 
subsets (the power set).

The solution set must not contain duplicate subsets. Return the solution in any order
 */
const subsets = (nums) => {
    //  this will contain all the subsets    
    const result = []

    const backTrack = (startIndex, currSubset) => {
        //  we need all possible subsets
        result.push([...currSubset])

        //  find all possible subsets going forward
        for (let i = startIndex; i < nums.length; i++) {

            //  all possible subsets with the current element
            currSubset.push(nums[i])
            backTrack(i + 1, currSubset)

            //  remove the current element for the next iteration of for loop            
            currSubset.pop()
        }
    }

    backTrack(0, [])

    return result
};

/* Letter tile possibilities - You have n  tiles, where each tile has one letter tiles[i] printed on it.

Return the number of possible non-empty sequences of letters you can make using the letters printed on those tiles.
 */
const numTilePossibilities = (tiles) => {
    const set = new Set()

    const backTrack = (currSeq, leftTiles) => {
        if (currSeq.length > 0) {
            set.add(currSeq)
        }
        for (let i = 0; i < leftTiles.length; i++) {
            const newSeq = currSeq + leftTiles[i]
            const newLeftTiles = leftTiles.slice(0, i) + leftTiles.slice(i + 1)
            backTrack(newSeq, newLeftTiles)
        }
    }
    backTrack('', tiles)
    return set.size
};

