/* Possible Bipartition - We want to split a group of n people (labeled from 1 to n) into two groups of any size. Each person may dislike some other people, and they should not go into the same group.

Given the integer n and the array dislikes where dislikes[i] = [ai, bi] indicates that the person labeled ai does not like the person labeled bi, return true if it is possible to split everyone into two groups in this way.
 */
/**
 * @param {number} n
 * @param {number[][]} dislikes
 * @return {boolean}
 */
const possibleBipartition = (n, dislikes) => {
    //  Create the adjacency list graph
    //  notice label is from 1 to n
    const adjList = Array(n + 1).fill(null).map(() => []);
    for (const [a, b] of dislikes) {
        // Add edges to the adjacency list
        adjList[a].push(b);
        adjList[b].push(a);
    }

    // Initialize an array to store the color of each node
    const color = new Array(n + 1).fill(0);
    // 0: not colored, 1: color 1, -1: color 2

    for (let node = 1; node <= n; node++) {
        // Iterate through the nodes

        if (color[node] !== 0) {
            // Found a colored node; skip it as it is already processed
            continue;
        }

        // We will do BFS from this node
        const queue = [node];
        color[node] = 1;

        while (queue.length) {
            const currNode = queue.shift();

            // Check the neighbors and color them
            for (const neighbor of adjList[currNode]) {
                if (color[neighbor] === color[currNode]) {
                    // Condition is broken - hateful neighbors
                    return false;
                }
                if (color[neighbor] === 0) {
                    // Color the neighbor with the opposite color
                    color[neighbor] = -color[currNode];
                    // Add in the queue for BFS
                    queue.push(neighbor);
                }
            }
        }
    }
    // All nodes are colored without conflicts, so the graph can be bipartitioned
    return true;
};

/* Minimum Knight Moves - In an infinite chess board with coordinates from -infinity to +infinity, you have a knight at square [0, 0].
A knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.
Return the minimum number of steps needed to move the knight to the square [x, y]. It is guaranteed the answer exists.
 */
const minKnightMoves = (x, y) => {
    // Notice the chess board is infinite
    let minSteps = 0;

    // Possible moves for the knight
    const offsets = [
        [1, 2], [-1, 2], [-2, 1], [-2, -1],
        [2, 1], [2, -1], [1, -2], [-1, -2]
    ];

    // We are using an array to save time; otherwise, time limit will be exceeded
    const visitedArr = Array(607).fill(null).map(() => Array(607).fill(false));

    // Queue to store the indices for BFS traversal
    const indicesQueue = [];
    indicesQueue.push([0, 0]); // Starting position

    // BFS traversal
    while (indicesQueue.length > 0) {
        const queueSize = indicesQueue.length;

        // Process all indices at the current level before increasing minSteps
        for (let counter = 0; counter < queueSize; counter++) {
            const currPair = indicesQueue.shift(); // Dequeue the front pair

            // Check if the current position is the destination
            if (currPair[0] === x && currPair[1] === y) {
                // Found the destination
                return minSteps;
            }

            // Explore all possible moves from the current position
            for (const [dx, dy] of offsets) {
                const nextX = currPair[0] + dx;
                const nextY = currPair[1] + dy;

                // Adding 302 to ensure 302, 302 is the (0, 0) reference point
                if (!visitedArr[nextX + 302][nextY + 302]) {
                    // Mark the next position as visited and enqueue it for further exploration
                    indicesQueue.push([nextX, nextY]);
                    visitedArr[nextX + 302][nextY + 302] = true;
                }
            }
        }

        // Move to the next level of positions
        minSteps++;
    }

    // If the destination is not reachable
    return -1;
}

/* Alien Dictionary - There is a new alien language that uses the English alphabet. However, the order among the letters is unknown to you.

You are given a list of strings words from the alien language's dictionary, where the strings in words are sorted lexicographically by the rules of this new language.

Return a string of the unique letters in the new alien language sorted in lexicographically increasing order by the new language's rules. If there is no solution, return "". If there are multiple solutions, return any of them.
 */
const alienOrder = (words) => {
    // Create a map to represent the graph of characters and their relationships
    const charGraph = new Map();
    // Create a map to store the indegree (number of incoming edges) for each character
    const inDegree = new Map();

    // Initialize the graph nodes and indegree for each node
    for (const word of words) {
        for (const char of word) {
            inDegree.set(char, 0);
            charGraph.set(char, new Set());
        }
    }

    // Iterate through each pair of adjacent words
    for (let i = 0; i < words.length - 1; i++) {
        const currWord = words[i];
        const nextWord = words[i + 1];

        // Check lexicographical order
        if (currWord.startsWith(nextWord) && currWord.length > nextWord.length) {
            // If the current word starts with the next word and is longer, it's not valid
            return "";
        }

        // Traverse through each character in the smaller word
        for (let j = 0; j < Math.min(currWord.length, nextWord.length); j++) {
            const currWordChar = currWord[j];
            const nextWordChar = nextWord[j];

            // If characters are different, create an edge in the graph
            if (currWordChar !== nextWordChar) {
                if (!charGraph.get(currWordChar).has(nextWordChar)) {
                    // Build the edge
                    charGraph.get(currWordChar).add(nextWordChar);
                    // Increase the indegree of the next node
                    inDegree.set(nextWordChar, (inDegree.get(nextWordChar) || 0) + 1);
                }
                // Take only one new edge per word
                break;
            }
        }
    }

    // Create a queue for Breadth-First Search (BFS)
    const bfsQueue = [];
    // Array to store the result (topological order)
    const result = [];
    // Set to keep track of visited nodes
    const seen = new Set();

    //  Initialize the BFS queue with nodes having an indegree of 0
    //  potential starting chars of the dictionary
    for (const [char, degree] of inDegree) {
        if (degree === 0) {
            bfsQueue.push(char);
        }
    }

    // Perform BFS
    while (bfsQueue.length > 0) {
        // Dequeue a character from the queue
        const currChar = bfsQueue.shift();
        // Append the character to the result
        result.push(currChar);
        // Mark the character as visited
        seen.add(currChar);

        // Update indegrees of adjacent characters and enqueue those with indegree 0
        for (const nextChar of charGraph.get(currChar)) {
            inDegree.set(nextChar, inDegree.get(nextChar) - 1);
            if (inDegree.get(nextChar) === 0) {
                //  unlocked a new char
                bfsQueue.push(nextChar);
            }
        }
    }

    // Check if all nodes have been visited (no cycles) and return the result as a string
    return seen.size === charGraph.size ? result.join('') : '';
}

/* Word Ladder - A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:
Every adjacent pair of words differs by a single letter.
Every si for 1 <= i <= k is in wordList.Note that beginWord does not need to be in wordList.
    sk == endWord
Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.
 */
/**
 * @param {string} beginWord
 * @param {string} endWord
 * @param {string[]} wordList
 * @return {number}
 */
const ladderLength = (beginWord, endWord, wordList) => {
    // Create a set for faster lookup
    const map = new Set(wordList);

    // If the end word is not in the word list, it's not possible to transform
    if (!map.has(endWord)) {
        return 0;
    }

    let steps = 1; // Initialize the number of transformations

    let queue = [beginWord]; // Start BFS with the initial word
    while (queue.length) {
        const next = []; // Initialize the next level of words to explore
        for (const curr of queue) {
            if (curr === endWord) {
                return steps; // If we reached the endWord, return the number of transformations
            }

            for (let i = 0; i < curr.length; i++) {
                //  try to transform each char one at a time as per condition
                for (let j = 0; j < 26; j++) {
                    // Generate next possible word by changing one letter at a time
                    const nextWord = curr.slice(0, i) + String.fromCharCode(97 + j) + curr.slice(i + 1);

                    if (map.has(nextWord)) {
                        next.push(nextWord); // Add valid next words to the queue for exploration
                        map.delete(nextWord); // Remove the word from the set to avoid repetition
                    }
                }
            }
        }
        queue = next; // Move to the next level of words
        steps++; // Increment the number of transformations
    }

    return 0; // If no transformation sequence is found, return 0
};

/* Minimum Genetic Mutation - Given the two gene strings startGene and endGene and the gene bank bank, return the minimum number of mutations needed to mutate from startGene to endGene. If there is no such a mutation, return -1.

Note that the starting point is assumed to be valid, so it might not be included in the bank.
 */
/**
 * @param {string} startGene
 * @param {string} endGene
 * @param {string[]} bank
 * @return {number}
 */
const minMutation = (startGene, endGene, bank) => {
    // Define the valid mutations that can occur
    const validMutations = ['A', 'C', 'G', 'T'];

    // Convert the bank array to a set for faster lookup
    const bankSet = new Set(bank);

    // Check if the end gene is not in the bank, return -1 as it's not possible
    if (!bankSet.has(endGene)) {
        return -1;
    }

    // Set to keep track of visited genes
    const visitedGenes = new Set();

    // Queue for BFS, each element is [gene, mutations]
    const bfsQueue = [[startGene, 0]];

    // Mark the start gene as visited
    visitedGenes.add(startGene);

    // BFS loop
    while (bfsQueue.length > 0) {
        // Dequeue the current gene and its mutations
        const [currGene, mutations] = bfsQueue.shift();

        // Check if the current gene is the end gene
        if (currGene === endGene) {
            // Found the end gene, return the number of mutations
            return mutations;
        }

        // Loop through each character in the current gene
        for (let i = 0; i < currGene.length; i++) {
            // Loop through each valid mutation
            for (let mutationChar of validMutations) {
                // Skip if the current character is the same as the mutation character
                if (currGene[i] === mutationChar) {
                    continue;
                }

                // Create a new gene with the mutation
                const newGene = currGene.slice(0, i) + mutationChar + currGene.slice(i + 1);

                // Check if the new gene is in the bank and has not been visited
                if (bankSet.has(newGene) && !visitedGenes.has(newGene)) {
                    // Found a new valid unvisited gene, enqueue it with mutations + 1
                    bfsQueue.push([newGene, mutations + 1]);
                    // Mark the new gene as visited
                    visitedGenes.add(newGene);
                }
            }
        }
    }

    // If the end gene is not reachable, return -1
    return -1;
};

/* Shortest Path to Get Food */

const getFood = grid => {
    // Get the number of rows and columns in the grid
    const rows = grid.length;
    const cols = grid[0].length;

    // Find the starting position of the person marked with '*'
    let startX, startY;
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if (grid[i][j] === '*') {
                startX = i;
                startY = j;
                break;
            }
        }
    }

    // Define the possible directions to move (up, down, left, right)
    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];

    // Create a set to keep track of visited cells to avoid revisiting them
    const visited = new Set();

    // Function to check if a given position is valid (within the grid boundaries)
    const isValid = (x, y) => x >= 0 && x < rows && y >= 0 && y < cols;

    // Initialize the queue with the starting position and the number of steps taken
    const queue = [[startX, startY, 0]];

    while (queue.length > 0) {
        // Dequeue the current position and steps taken
        const [x, y, steps] = queue.shift();

        // Check if food is found at the current position
        if (grid[x][y] === '#') {
            return steps; // Return the number of steps taken when food is found
        }

        // Explore neighbors in all possible directions
        for (const [dx, dy] of directions) {
            const newX = x + dx;
            const newY = y + dy;

            // Check if the new position is valid and has not been visited before
            if (isValid(newX, newY) && grid[newX][newY] !== 'X' && !visited.has(`${newX}-${newY}`)) {
                visited.add(`${newX}-${newY}`); // Mark the new position as visited
                queue.push([newX, newY, steps + 1]); // Enqueue the new position with updated steps
            }
        }
    }

    // Return -1 if no food is found (should not happen if the grid is well-formed)
    return -1;
};
