Water trap - Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.

/**
 * @param {number[]} height
 * @return {number}
 */
const trap = (heights) => {
    let leftMaxH = 0
    let rightMaxH = 0
    let left = 0
    let right = heights.length - 1

    let res = 0

    while (left <= right) {
        //  find max height of water
        if (leftMaxH <= rightMaxH) {
            if (leftMaxH <= heights[left]) {
                //  found a taller wall
                leftMaxH = heights[left]
            } else {
                //  this much water can be held at this index
                res += Math.min(leftMaxH, rightMaxH) - heights[left]
            }
            left += 1
        } else {
            if (rightMaxH <= heights[right]) {
                rightMaxH = heights[right]
            } else {
                res += Math.min(leftMaxH, rightMaxH) - heights[right]
            }
            right -= 1
        }
    }

    return res
};

/* Container With Most Water - You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).
Find two lines that together with the x-axis form a container, such that the container contains the most water.
Return the maximum amount of water a container can store.
 */
 
 var maxArea = function (height) {
    //  solve using two pointers

    let left = 0
    let right = height.length - 1

    let maxArea = 0

    while (left < right) {
        //  Area will be minimum of two heights
        const currArea = (right - left) * Math.min(height[left], height[right])
        if (currArea > maxArea) {
            maxArea = currArea
        }

        //  search for better height
        if (height[left] < height[right]) {
            left++
        } else {
            right--
        }
    }

    return maxArea
};



3Sum - Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.

Notice that the solution set must not contain duplicate triplets.

class Solution {
    fun threeSum(nums: IntArray): List<List<Int>> {
//  we need 3 pointers 

        val resultList = mutableListOf<List<Int>>()

//  sort the array
        val sortedNums = nums.sorted()

        for(firstPointer in 0 until sortedNums.size - 2){
//  last 2 pointers are for second and third pointers

            if(firstPointer > 0 && sortedNums[firstPointer] == sortedNums[firstPointer - 1]){
//  triplets have to be unique
                continue
            }

            var secondPointer = firstPointer + 1
            var thirdPointer = sortedNums.size - 1

            while(secondPointer < thirdPointer){
                var currSum = sortedNums[firstPointer] + sortedNums[secondPointer] + sortedNums[thirdPointer]

                when{
                    currSum == 0 -> {
//  we found a triplet
                        resultList.add(listOf(sortedNums[firstPointer], sortedNums[secondPointer], sortedNums[thirdPointer]))

//  maintain uniqueness
                        while(secondPointer < thirdPointer && sortedNums[secondPointer] == sortedNums[secondPointer + 1]){
                            secondPointer++
                        }
                        while(secondPointer < thirdPointer && sortedNums[thirdPointer] == sortedNums[thirdPointer - 1]){
                            thirdPointer--
                        }
                        secondPointer++
                        thirdPointer--
                    }
                    
//  because it is a sorted list, we need to move to right
                    currSum < 0 -> secondPointer++
                    else -> thirdPointer--
                }
            }
        }

        return resultList
    }
}


Next Permutation - The next permutation of an array of integers is the next lexicographically greater permutation of its integer. 

class Solution {
    fun nextPermutation(nums: IntArray): Unit {
//  consider 1, 5, 8, 4, 7, 6, 5, 3, 1

        var firstPointer = nums.size - 2
//  travel from right end and find a point firstPointer where [firstPointer + 1] element is higher than firstPointer element
        while(firstPointer >= 0 && nums[firstPointer] >= nums[firstPointer + 1]){
            firstPointer--
        }

        if(firstPointer >= 0){
            var secondPointer = nums.size - 1
            while(nums[secondPointer] <= nums[firstPointer]){
//  find a number which is greater than our firstPointer item
                secondPointer--
//  notice that secondPointer will always be on the right of firstPointer                
            }
            swap(nums, firstPointer, secondPointer)
//  swap 4 with 5 -> 1, 5, 8, 5, 7, 6, 4, 3, 1            
        }

        reverse(nums, firstPointer + 1)
//  to find the next larger number -> 1, 5, 8, 5, 1, 3, 4, 6, 7
    }

    fun swap(nums: IntArray, i: Int, j: Int){
        val temp = nums[i]
        nums[i] = nums[j]
        nums[j] = temp
    }

    fun reverse(nums: IntArray, startIndex: Int){
        var left = startIndex
        var right = nums.size - 1

        while(left < right){
            swap(nums, left, right)
            left++
            right--
        }
    }
}



3Sum Closest - Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.
Return the sum of the three integers.

class Solution {
    fun threeSumClosest(nums: IntArray, target: Int): Int {
        var diff = Int.MAX_VALUE
        val arrSize = nums.size

        Arrays.sort(nums)

        var first = 0
        while(first <= arrSize - 3 && diff != 0){
//  we want the closest not the exact one

            var sec = first + 1
            var third = arrSize - 1

            while(sec < third){
                val sum = nums[first] + nums[sec] + nums[third]
                if(Math.abs(target - sum) < Math.abs(diff)){
//  found a closer one
                    diff = target - sum                    
                }
                if(sum < target){
//  move the second pointer
                    sec++                    
                }
                else{
                    third--
                }
            }
            first++
        }

//  closest sum
        return target - diff
    }
}

/* Sort Colors - Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.

We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.
 */
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
const sortColors = (nums) => {
    let zero = 0
    let two = nums.length - 1

    for (let i = 0; i < nums.length; i++) {
        while (nums[zero] === 0) {
            zero++
        }
        while (nums[two] === 2) {
            two--
        }
        const currNum = nums[i]
        if (currNum === 0 && i > zero) {
            [nums[zero], nums[i]] = [nums[i], nums[zero]]
            i--
        }
        if (currNum === 2 && i < two) {
            [nums[two], nums[i]] = [nums[i], nums[two]]
            i--
        }
    }
};

/* Partition array as per given pivot - You are given a 0-indexed integer array nums and an integer pivot. 
Every element less than pivot appears before every element greater than pivot.
Every element equal to pivot appears in between the elements less than and greater than pivot.
The relative order of the elements less than pivot and the elements greater than pivot is maintained.
Return nums after the rearrangement.
 */
/**
 * @param {number[]} nums
 * @param {number} pivot
 * @return {number[]}
 */
const pivotArray = (nums, pivot) => {

    //  we will use two pointers approach

    let len = nums.length
    let output = []

    let i = 0
    let j = len - 1

    let lowElementsIndex = 0
    let highElementsIndex = len - 1

    while (i < len) {
        //  fill small numbers to left
        if (nums[i] < pivot) {
            output[lowElementsIndex++] = nums[i]
        }
        //  fill large numbers to right
        if (nums[j] > pivot) {
            output[highElementsIndex--] = nums[j]
        }

        i++
        j--
    }

    //  if there is some space left
    while (lowElementsIndex <= highElementsIndex) {
        output[lowElementsIndex++] = pivot
    }

    return output
};

/* 
Two Sum Less Than K - 
 */

 /**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
const twoSumLessThanK = (nums, k) => {
    // Sort the array in ascending order
    nums.sort((a, b) => a - b);
    
    let left = 0;
    let right = nums.length - 1;
    let maxSum = -1;
    
    while (left < right) {
        const sum = nums[left] + nums[right];
        
        // If the sum is less than k, update maxSum and move the left pointer to the right
        if (sum < k) {
            maxSum = Math.max(maxSum, sum);
            left++;
        } else {
            // If the sum is greater than or equal to k, move the right pointer to the left
            right--;
        }
    }
    
    return maxSum;
};

/* 
Two sum - variation - Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length.

Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.

The tests are generated such that there is exactly one solution. You may not use the same element twice.

Your solution must use only constant extra space.
 */

/**
 * @param {number[]} numbers
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function (nums, k) {
    let left = 0;
    let right = nums.length - 1;
    let ans;

    while (left < right) {
        const sum = nums[left] + nums[right];

        if (sum < k) {
            left++;
        } else if (sum > k) {
            right--;
        } else {
            //  one sol as per condition
            ans = [left + 1, right + 1]
            break
        }
    }

    return ans;
};