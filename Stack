/* Valid parentheses - Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
 */
const isValid = (s) => {
    const stack = []
    const bracketMap = {
        ')': '(',
        '}': '{',
        ']': '['
    };

    for (let i = 0; i < s.length; i++) {
        const currentBracket = s[i]
        if (bracketMap.hasOwnProperty(currentBracket)) {
            // If it's a closing bracket
            const topElement = stack.length === 0 ? '#' : stack.pop();
            if (bracketMap[currentBracket] !== topElement) {
                return false;
            }
        } else {
            // If it's an opening bracket
            stack.push(currentBracket);
        }
    }

    return stack.length === 0
};



Decode String - Given an encoded string, return its decoded string.

The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.

class Solution {
    fun decodeString(s: String): String {

        var currRepeatNum = 0
        val stack = mutableListOf<String>()
        var currString = ""

        for(char in s){
            when{
                char.isDigit() -> {
//  think of finding the digit 892                    
                    currRepeatNum = currRepeatNum * 10 + (char - '0')
                }
                
                char == '[' -> {
//  new string is coming
                    stack.add(currString)                    
//  save the string made so far
                    stack.add(currRepeatNum.toString())

//  prepare for new string
                    currString = ""
                    currRepeatNum = 0
                }

                char == ']' -> {
//  process and save the current string
                    val numRepeat = stack.removeAt(stack.size - 1).toInt()
                    var stringMadeSoFar = stack.removeAt(stack.size - 1)

                    stringMadeSoFar += currString.repeat(numRepeat)
                    currString = stringMadeSoFar
                }

                else -> {
                    currString += char
                }
            }
        }

        return currString
    }
}



Remove All Adjacent Duplicates in String  - You are given a string s and an integer k, a k duplicate removal consists of choosing k adjacent and equal letters from s and removing them, causing the left and the right side of the deleted substring to concatenate together.

We repeatedly make k duplicate removals on s until we no longer can.

Return the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique.

class Solution {
    data class CharCountPair(val char: Char, var count: Int)

    fun removeDuplicates(s: String, k: Int): String {
        val stack = Stack<CharCountPair>()

        for(counter in 0 until s.length){
            if(stack.isEmpty() || s[counter] != stack.peek().char){
                stack.push(CharCountPair(s[counter], 1))
            }else{
                val duplicatePair = stack.peek()
//  keep the count in case we don't delete this character
                duplicatePair.count++
                if(duplicatePair.count == k){
                    stack.pop()
                }
            }
        }

        val strBuilder = StringBuilder()
        while(!stack.isEmpty()){
            val pair = stack.pop()
            for(counter in 0 until pair.count){
                strBuilder.append(pair.char)
            }
        }

//  reverse because last characters are added first in the builder
        return strBuilder.reverse().toString()
    }
}



Daily Temperatures - Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.

class Solution {
    fun dailyTemperatures(temperatures: IntArray): IntArray {
//  we will solve this using stack

        val numDays = temperatures.size
        val answerArray = IntArray(numDays)

        val indexStack = LinkedList<Int>()

        for(currDayIndex in 0 until numDays){
            val currDayTemp = temperatures[currDayIndex]

            while(!indexStack.isEmpty() && temperatures[indexStack.peek()] < currDayTemp){
//  find if there are days for which this day is warmer
//  there could be multiple days - prev day was not warmer for the prev to prev could be the case                
                val prevDayIndex = indexStack.removeAt(0)
                answerArray[prevDayIndex] = currDayIndex - prevDayIndex
            }
            indexStack.add(0, currDayIndex)
        }

        return answerArray
    }
}



Online Stock Span - Design an algorithm that collects daily price quotes for some stock and returns the span of that stock's price for the current day.

The span of the stock's price in one day is the maximum number of consecutive days (starting from that day and going backward) for which the stock price was less than or equal to the price of that day.

class StockSpanner() {

    val prices = mutableListOf<Int>()
    val spans = mutableListOf<Int>()
//  maintain the span of price at each index    

    fun next(price: Int): Int {
        prices.add(price)
        var span = 1
//  by default span is 1

        var counter = prices.size - 2
//  start the counter just before added price

        while(counter >= 0 && prices[counter] <= price){
//  add the span of prev price's span            
            span += spans[counter]
//  move the counter back because these spans are counted already            
            counter -= spans[counter]
        }

        spans.add(span)

        return span
    }

}

/**
 * Your StockSpanner object will be instantiated and called as such:
 * var obj = StockSpanner()
 * var param_1 = obj.next(price)
 */



Next Greater Element - Given a circular integer array nums (i.e., the next element of nums[nums.length - 1] is nums[0]), return the next greater number for every element in nums.

The next greater number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, return -1 for this number.

class Solution {
    fun nextGreaterElements(nums: IntArray): IntArray {
        val resultArr = IntArray(nums.size)

        val indexStack = Stack<Int>()

        for(counter in 2 * nums.size - 1 downTo 0){
//  traverse the array twice to counter rotation
//  travelling from the last is mandatory

            while(!indexStack.isEmpty() 
                        && nums[indexStack.peek()] <= nums[counter % nums.size]){
//  find the index which has greater item than the current item
                indexStack.pop()
            }

            if(indexStack.isEmpty()){
//  no item exists                
                resultArr[counter % nums.size] = -1
            }else{
                resultArr[counter % nums.size] = nums[indexStack.peek()]
            }

//  push the item as this one could be greater for another item
            indexStack.push(counter % nums.size)
        }

        return resultArr
    }
}

/* Minimum add to make parentheses valid - find the minimum number of parentheses to add to make a given string of parentheses valid
 */
const minAddToMakeValid = (s) => {
    const stack = []

    for (const char of s) {
        if (char === '(') {
            stack.push(char)
        } else {
            if (stack.length > 0 && stack[stack.length - 1] === '(') {
                //  found a match
                stack.pop()
            } else {
                //  no match, add this parenthesis for calculation
                stack.push(char)
            }
        }
    }

    //  unmatched parentheses are still in stack
    return stack.length
};

/* Min remove to make valid parentheses - Given a string s of '(' , ')' and lowercase English characters.

Your task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string.

Formally, a parentheses string is valid if and only if:

It is the empty string, contains only lowercase characters, or
It can be written as AB (A concatenated with B), where A and B are valid strings, or
It can be written as (A), where A is a valid string.
 */

/**
 * @param {string} s
 * @return {string}
 */
const minRemoveToMakeValid = (s) => {
    s = s.split('')

    const stack = []

    for(let i = 0; i < s.length; i++){
        if(s[i] === '('){
            //  keep the position 
            stack.push(i)
        }else if(s[i] === ')'){
            if(stack.length){
                stack.pop()
            }else{
                //  remove the invalid closing bracket
                s[i] = ''
            }
        }
    }

    for(let position of stack){
        //  remove the invalid opening bracket
        s[position] = ''
    }

    return s.join('')
};