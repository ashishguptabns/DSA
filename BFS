/* Possible Bipartition - We want to split a group of n people (labeled from 1 to n) into two groups of any size. Each person may dislike some other people, and they should not go into the same group.

Given the integer n and the array dislikes where dislikes[i] = [ai, bi] indicates that the person labeled ai does not like the person labeled bi, return true if it is possible to split everyone into two groups in this way.
 */
/**
 * @param {number} n
 * @param {number[][]} dislikes
 * @return {boolean}
 */
const possibleBipartition = (n, dislikes) => {
    // Create the adjacency list graph
    const adjList = new Array(n + 1).fill(null).map(() => []);
    for (const edge of dislikes) {
        // Add edges to the adjacency list
        adjList[edge[0]].push(edge[1]);
        adjList[edge[1]].push(edge[0]);
    }

    // Initialize an array to store the color of each node
    const color = new Array(n + 1).fill(0);
    // 0: not colored, 1: color 1, -1: color 2

    for (let node = 1; node <= n; node++) {
        // Iterate through the nodes

        if (color[node] !== 0) {
            // Found a colored node; skip it as it is already processed
            continue;
        }

        // We will do BFS from this node
        const queue = [node];
        color[node] = 1;

        while (queue.length) {
            const currNode = queue.shift();

            // Check the neighbors and color them
            for (const neighbor of adjList[currNode]) {
                if (color[neighbor] === color[currNode]) {
                    // Condition is broken - the same color is found in neighbors
                    return false;
                }
                if (color[neighbor] === 0) {
                    // Color the neighbor with the opposite color
                    color[neighbor] = -color[currNode];
                    // Add in the queue for BFS
                    queue.push(neighbor);
                }
            }
        }
    }
    // All nodes are colored without conflicts, so the graph can be bipartitioned
    return true;
};

/* The Maze - There is a ball in a maze with empty spaces (represented as 0) and walls (represented as 1). The ball can go through the empty spaces by rolling up, down, left or right, but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction.

Given the m x n maze, the ball's start position and the destination, where start = [startrow, startcol] and destination = [destinationrow, destinationcol], return true if the ball can stop at the destination, otherwise return false.
 */
const hasPath = (maze, start, destination) => {
    const [startRow, startCol] = start;
    const [destRow, destCol] = destination;
    const rows = maze.length;
    const cols = maze[0].length;
    const visited = Array.from({ length: rows }, () => Array(cols).fill(false));

    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];

    const dfs = (row, col) => {
        // Check if the current position is the destination
        if (row === destRow && col === destCol) {
            return true;
        }

        // Mark the current position as visited
        visited[row][col] = true;

        // Explore in all directions
        for (const [dr, dc] of directions) {
            let newRow = row;
            let newCol = col;

            // Keep rolling until hitting a wall
            while (
                newRow + dr >= 0 &&
                newRow + dr < rows &&
                newCol + dc >= 0 &&
                newCol + dc < cols &&
                maze[newRow + dr][newCol + dc] === 0
            ) {
                newRow += dr;
                newCol += dc;
            }

            // Check if the new position has not been visited
            if (!visited[newRow][newCol]) {
                // Recursively explore the new position
                if (dfs(newRow, newCol)) {
                    return true;
                }
            }
        }

        return false;
    };

    // Start DFS from the given start position
    return dfs(startRow, startCol);
};

/* Minimum Knight Moves - In an infinite chess board with coordinates from -infinity to +infinity, you have a knight at square [0, 0].
A knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.
Return the minimum number of steps needed to move the knight to the square [x, y]. It is guaranteed the answer exists.
 */
const minKnightMoves = (x, y) => {
    // Notice the chess board is infinite
    let minSteps = 0;

    // Possible moves for the knight
    const offsets = [
        [1, 2], [-1, 2], [-2, 1], [-2, -1],
        [2, 1], [2, -1], [1, -2], [-1, -2]
    ];

    // We are using an array to save time; otherwise, time limit will be exceeded
    const visitedArr = Array(607).fill(null).map(() => Array(607).fill(false));

    // Queue to store the indices for BFS traversal
    const indicesQueue = [];
    indicesQueue.push([0, 0]); // Starting position

    // BFS traversal
    while (indicesQueue.length > 0) {
        const queueSize = indicesQueue.length;

        // Process all indices at the current level before increasing minSteps
        for (let counter = 0; counter < queueSize; counter++) {
            const currPair = indicesQueue.shift(); // Dequeue the front pair

            // Check if the current position is the destination
            if (currPair[0] === x && currPair[1] === y) {
                // Found the destination
                return minSteps;
            }

            // Explore all possible moves from the current position
            for (const [dx, dy] of offsets) {
                const nextX = currPair[0] + dx;
                const nextY = currPair[1] + dy;

                // Adding 302 to ensure 302, 302 is the (0, 0) reference point
                if (!visitedArr[nextX + 302][nextY + 302]) {
                    // Mark the next position as visited and enqueue it for further exploration
                    indicesQueue.push([nextX, nextY]);
                    visitedArr[nextX + 302][nextY + 302] = true;
                }
            }
        }

        // Move to the next level of positions
        minSteps++;
    }

    // If the destination is not reachable
    return -1;
}

/* Alien Dictionary - There is a new alien language that uses the English alphabet. However, the order among the letters is unknown to you.

You are given a list of strings words from the alien language's dictionary, where the strings in words are sorted lexicographically by the rules of this new language.

Return a string of the unique letters in the new alien language sorted in lexicographically increasing order by the new language's rules. If there is no solution, return "". If there are multiple solutions, return any of them.
 */
const alienOrder = (words) => {
    // Create a map to represent the graph of characters and their relationships
    const charGraph = new Map();
    // Create a map to store the indegree (number of incoming edges) for each character
    const inDegree = new Map();

    // Initialize the graph nodes and indegree for each node
    for (const word of words) {
        for (const char of word) {
            inDegree.set(char, 0);
            charGraph.set(char, new Set());
        }
    }

    // Iterate through each pair of adjacent words
    for (let i = 0; i < words.length - 1; i++) {
        const currWord = words[i];
        const nextWord = words[i + 1];

        // Check lexicographical order
        if (currWord.startsWith(nextWord) && currWord.length > nextWord.length) {
            // If the current word starts with the next word and is longer, it's not valid
            return "";
        }

        // Traverse through each character in the smaller word
        for (let j = 0; j < Math.min(currWord.length, nextWord.length); j++) {
            const currWordChar = currWord[j];
            const nextWordChar = nextWord[j];

            // If characters are different, create an edge in the graph
            if (currWordChar !== nextWordChar) {
                if (!charGraph.get(currWordChar).has(nextWordChar)) {
                    // Build the edge
                    charGraph.get(currWordChar).add(nextWordChar);
                    // Increase the indegree of the next node
                    inDegree.set(nextWordChar, (inDegree.get(nextWordChar) || 0) + 1);
                }
                // Take only one new edge per word
                break;
            }
        }
    }

    // Create a queue for Breadth-First Search (BFS)
    const bfsQueue = [];
    // Array to store the result (topological order)
    const result = [];
    // Set to keep track of visited nodes
    const seen = new Set();

    // Initialize the BFS queue with nodes having an indegree of 0
    //  potential starting chars of the dictionary
    for (const [char, degree] of inDegree) {
        if (degree === 0) {
            bfsQueue.push(char);
        }
    }

    // Perform BFS
    while (bfsQueue.length > 0) {
        // Dequeue a character from the queue
        const currChar = bfsQueue.shift();
        // Append the character to the result
        result.push(currChar);
        // Mark the character as visited
        seen.add(currChar);

        // Update indegrees of adjacent characters and enqueue those with indegree 0
        for (const nextChar of charGraph.get(currChar)) {
            inDegree.set(nextChar, inDegree.get(nextChar) - 1);
            if (inDegree.get(nextChar) === 0) {
                bfsQueue.push(nextChar);
            }
        }
    }

    // Check if all nodes have been visited (no cycles) and return the result as a string
    return seen.size === charGraph.size ? result.join('') : '';
}

/* Word Ladder - A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:
Every adjacent pair of words differs by a single letter.
Every si for 1 <= i <= k is in wordList.Note that beginWord does not need to be in wordList.
    sk == endWord
Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.
 */
function ladderLength(beginWord: string, endWord: string, wordList: string[]): number {

    //  make the dictionary set from given words    
    const dictionary = new Set(wordList)
    if (!dictionary.has(endWord)) {
        //  word is not there hence we can't reach it
        return 0
    }

    //  now that we have the end word so min steps is 1 if we can reach the end word
    let steps = 1

    //  we will do the bfs    
    const wordsQueue = [beginWord]
    //  mark the word visited    
    const visited = new Set(wordsQueue)

    while (wordsQueue.length) {
        const currLevelSize = wordsQueue.length
        for (let i = 0; i < currLevelSize; i++) {
            //  remove the first element and return            
            const word = wordsQueue.shift()
            if (word === endWord) {
                //  found the end word                
                return steps
            }

            //  we will try to make new words for next travel
            for (let j = 0; j < word.length; j++) {
                for (let k = 0; k < 26; k++) {

                    //  String.fromCharCode(97) gives 'a'
                    const nextWord = word.slice(0, j)
                        + String.fromCharCode(97 + k)
                        + word.slice(j + 1)

                    //  add in the queue
                    if (dictionary.has(nextWord) && !visited.has(nextWord)) {
                        wordsQueue.push(nextWord)
                        visited.add(nextWord)
                    }
                }
            }
        }
        steps++
    }

    //  could not reach the end word
    return 0
};

/* Minimum Genetic Mutation - Given the two gene strings startGene and endGene and the gene bank bank, return the minimum number of mutations needed to mutate from startGene to endGene. If there is no such a mutation, return -1.

Note that the starting point is assumed to be valid, so it might not be included in the bank.
 */
/**
 * @param {string} startGene
 * @param {string} endGene
 * @param {string[]} bank
 * @return {number}
 */
const minMutation = (startGene, endGene, bank) => {
    // Define the valid mutations that can occur
    const validMutations = ['A', 'C', 'G', 'T'];

    // Convert the bank array to a set for faster lookup
    const bankSet = new Set(bank);

    // Check if the end gene is not in the bank, return -1 as it's not possible
    if (!bankSet.has(endGene)) {
        return -1;
    }

    // Set to keep track of visited genes
    const visitedGenes = new Set();

    // Queue for BFS, each element is [gene, mutations]
    const bfsQueue = [[startGene, 0]];

    // Mark the start gene as visited
    visitedGenes.add(startGene);

    // BFS loop
    while (bfsQueue.length > 0) {
        // Dequeue the current gene and its mutations
        const [currGene, mutations] = bfsQueue.shift();

        // Check if the current gene is the end gene
        if (currGene === endGene) {
            // Found the end gene, return the number of mutations
            return mutations;
        }

        // Loop through each character in the current gene
        for (let i = 0; i < currGene.length; i++) {
            // Loop through each valid mutation
            for (let mutationChar of validMutations) {
                // Skip if the current character is the same as the mutation character
                if (currGene[i] === mutationChar) {
                    continue;
                }

                // Create a new gene with the mutation
                const newGene = currGene.slice(0, i) + mutationChar + currGene.slice(i + 1);

                // Check if the new gene is in the bank and has not been visited
                if (bankSet.has(newGene) && !visitedGenes.has(newGene)) {
                    // Found a new valid unvisited gene, enqueue it with mutations + 1
                    bfsQueue.push([newGene, mutations + 1]);
                    // Mark the new gene as visited
                    visitedGenes.add(newGene);
                }
            }
        }
    }

    // If the end gene is not reachable, return -1
    return -1;
};

/* Same tree - Given the roots of two binary trees p and q, write a function to check if they are the same or not.
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
const isSameTree = (p, q) => {
    if (!p && !q) {
        return true
    }
    if ((p && !q) || (!p && q) || (p.val !== q.val)) {
        return false
    }

    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
};



Deepest leaves sum - Given the root of a binary tree, return the sum of values of its deepest leaves.

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
const deepestLeavesSum = (root) => {

    // solve this using BFS
    // keep tracking the sum and return the last level's

    if (!root) {
        return 0
    }

    const queue = [root]
    let levelSum

    while (queue.length > 0) {
        const currLevelSize = queue.length
        levelSum = 0

        for (let i = 0; i < currLevelSize; i++) {
            const node = queue.shift()
            levelSum += node.val

            if (node.left) {
                queue.push(node.left)
            }
            if (node.right) {
                queue.push(node.right)
            }
        }
    }

    return levelSum
};

/* Shortest Path to Get Food */

// Function to find the minimum steps required to reach food ('#') from the person's starting position ('*') on a 2D grid.
const getFood = grid => {
    // Get the number of rows and columns in the grid
    const rows = grid.length;
    const cols = grid[0].length;

    // Find the starting position of the person marked with '*'
    let startX, startY;
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if (grid[i][j] === '*') {
                startX = i;
                startY = j;
                break;
            }
        }
    }

    // Define the possible directions to move (up, down, left, right)
    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];

    // Create a set to keep track of visited cells to avoid revisiting them
    const visited = new Set();

    // Function to check if a given position is valid (within the grid boundaries)
    const isValid = (x, y) => x >= 0 && x < rows && y >= 0 && y < cols;

    // Breadth-first search algorithm to find the minimum steps to reach food
    const bfs = () => {
        // Initialize the queue with the starting position and the number of steps taken
        const queue = [[startX, startY, 0]];

        while (queue.length > 0) {
            // Dequeue the current position and steps taken
            const [x, y, steps] = queue.shift();

            // Check if food is found at the current position
            if (grid[x][y] === '#') {
                return steps; // Return the number of steps taken when food is found
            }

            // Explore neighbors in all possible directions
            for (const [dx, dy] of directions) {
                const newX = x + dx;
                const newY = y + dy;

                // Check if the new position is valid and has not been visited before
                if (isValid(newX, newY) && grid[newX][newY] !== 'X' && !visited.has(`${newX}-${newY}`)) {
                    visited.add(`${newX}-${newY}`); // Mark the new position as visited
                    queue.push([newX, newY, steps + 1]); // Enqueue the new position with updated steps
                }
            }
        }

        // Return -1 if no food is found (should not happen if the grid is well-formed)
        return -1;
    };

    // Start BFS to find the minimum steps
    const result = bfs();

    // Return the result, which is either the minimum steps or -1 if no food is found
    return result;
};
