/* Possible Bipartition - We want to split a group of n people (labeled from 1 to n) into two groups of any size. Each person may dislike some other people, and they should not go into the same group.

Given the integer n and the array dislikes where dislikes[i] = [ai, bi] indicates that the person labeled ai does not like the person labeled bi, return true if it is possible to split everyone into two groups in this way.
 */
/**
 * @param {number} n
 * @param {number[][]} dislikes
 * @return {boolean}
 */
const possibleBipartition = (n, dislikes) => {
    // Create the adjacency list graph
    const adjList = new Array(n + 1).fill(null).map(() => []);
    for (const edge of dislikes) {
        // Add edges to the adjacency list
        adjList[edge[0]].push(edge[1]);
        adjList[edge[1]].push(edge[0]);
    }

    // Initialize an array to store the color of each node
    const color = new Array(n + 1).fill(0);
    // 0: not colored, 1: color 1, -1: color 2

    for (let node = 1; node <= n; node++) {
        // Iterate through the nodes

        if (color[node] !== 0) {
            // Found a colored node; skip it as it is already processed
            continue;
        }

        // We will do BFS from this node
        const queue = [node];
        color[node] = 1;

        while (queue.length) {
            const currNode = queue.shift();

            // Check the neighbors and color them
            for (const neighbor of adjList[currNode]) {
                if (color[neighbor] === color[currNode]) {
                    // Condition is broken - the same color is found in neighbors
                    return false;
                }
                if (color[neighbor] === 0) {
                    // Color the neighbor with the opposite color
                    color[neighbor] = -color[currNode];
                    // Add in the queue for BFS
                    queue.push(neighbor);
                }
            }
        }
    }
    // All nodes are colored without conflicts, so the graph can be bipartitioned
    return true;
};

/* The Maze - There is a ball in a maze with empty spaces (represented as 0) and walls (represented as 1). The ball can go through the empty spaces by rolling up, down, left or right, but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction.

Given the m x n maze, the ball's start position and the destination, where start = [startrow, startcol] and destination = [destinationrow, destinationcol], return true if the ball can stop at the destination, otherwise return false.
 */
const hasPath = (maze, start, destination) => {
    const [startRow, startCol] = start;
    const [destRow, destCol] = destination;
    const rows = maze.length;
    const cols = maze[0].length;
    const visited = Array.from({ length: rows }, () => Array(cols).fill(false));

    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];

    const dfs = (row, col) => {
        // Check if the current position is the destination
        if (row === destRow && col === destCol) {
            return true;
        }

        // Mark the current position as visited
        visited[row][col] = true;

        // Explore in all directions
        for (const [dr, dc] of directions) {
            let newRow = row;
            let newCol = col;

            // Keep rolling until hitting a wall
            while (
                newRow + dr >= 0 &&
                newRow + dr < rows &&
                newCol + dc >= 0 &&
                newCol + dc < cols &&
                maze[newRow + dr][newCol + dc] === 0
            ) {
                newRow += dr;
                newCol += dc;
            }

            // Check if the new position has not been visited
            if (!visited[newRow][newCol]) {
                // Recursively explore the new position
                if (dfs(newRow, newCol)) {
                    return true;
                }
            }
        }

        return false;
    };

    // Start DFS from the given start position
    return dfs(startRow, startCol);
};

/* Minimum Knight Moves - In an infinite chess board with coordinates from -infinity to +infinity, you have a knight at square [0, 0].
A knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.
Return the minimum number of steps needed to move the knight to the square [x, y]. It is guaranteed the answer exists.
 */
class Solution {
    fun minKnightMoves(x: Int, y: Int): Int {
//  notice the chess board is infinite
        var minSteps = 0

        val offsets = arrayOf(Pair(1, 2), Pair(-1, 2), Pair(-2, 1), Pair(-2, -1), 
                        Pair(2, 1), Pair(2, -1), Pair(1, -2), Pair(-1, -2))

//  we are using array to save time else time limit will be exceeded
        val visitedArr = Array(607, { BooleanArray(607) })

        val indicesQueue = LinkedList<Pair<Int, Int>>()
        indicesQueue.offer(Pair(0, 0))

        while(indicesQueue.isNotEmpty()){
            val queueSize = indicesQueue.size

            for(counter in 0 until queueSize){
//  this for loop is important because we want to process the whole level before increasing minSteps                
                val currPair = indicesQueue.poll()
                
                if(currPair.first == x && currPair.second == y){
//  found the destination                
                    return minSteps 
                }
                
                for((dx, dy) in offsets){
                    val nextX = currPair.first + dx
                    val nextY = currPair.second + dy

//  adding 302 to ensure 302, 302 is the 0, 0
                    if(!visitedArr[nextX + 302][nextY + 302]){
//  next level of points                        
                        indicesQueue.offer(Pair(nextX, nextY))
                        visitedArr[nextX + 302][nextY + 302] = true
                    }
                }
            }

            minSteps++
        }

        return -1
    }
}

/* Alien Dictionary - There is a new alien language that uses the English alphabet. However, the order among the letters is unknown to you.

You are given a list of strings words from the alien language's dictionary, where the strings in words are 
sorted lexicographically
 by the rules of this new language.

Return a string of the unique letters in the new alien language sorted in lexicographically increasing order by the new language's rules. If there is no solution, return "". If there are multiple solutions, return any of them.
 */
class Solution {
    fun alienOrder(words: Array<String>): String {
        val charGraph = mutableMapOf<Char, MutableSet<Char>>()
        val inDegree = mutableMapOf<Char, Int>()

//  init the graph nodes and indegree for each node
        for(word in words){
            for(char in word){
                inDegree[char] = 0
                charGraph[char] = mutableSetOf()
            }
        }

        for(i in 0 until words.size - 1){
//  travel through each word            
            val currWord = words[i]
            val nextWord = words[i + 1]

            if(currWord.startsWith(nextWord) && currWord.length > nextWord.length){
//  as per the lexicographical condition
                return ""
            }

            for(j in 0 until minOf(currWord.length, nextWord.length)){
//  travel through each char in small word
                val currWordChar = currWord[j]
                val nextWordChar = nextWord[j]

                if(currWordChar != nextWordChar){
                    if(!charGraph[currWordChar]!!.contains(nextWordChar)){
//  build the edge
                        charGraph[currWordChar]!!.add(nextWordChar)
//  set the indegree of next node
                        inDegree[nextWordChar] = inDegree.getOrDefault(nextWordChar, 0) + 1
                    }
//  notice this. we are taking only one new edge per word
                    break
                }
            }
        }

        val bfsQueue = LinkedList<Char>()
        val sb = StringBuilder()
        val seen = mutableSetOf<Char>()

        for((char, degree) in inDegree){
            if(degree == 0){
//  start from nodes in the order of indegrees
                bfsQueue.offer(char)
            }
        }

        while(bfsQueue.isNotEmpty()){
            val currChar = bfsQueue.poll()
            sb.append(currChar)
            seen.add(currChar)

            for(nextChar in charGraph[currChar]!!){
//  this is topological sorting
                inDegree[nextChar] = inDegree[nextChar]!! - 1
                if(inDegree[nextChar] == 0){
                    bfsQueue.offer(nextChar)
                }
            }
        }

//  ensure that we have visited all the nodes
        return if(seen.size == charGraph.size) sb.toString() else ""
    }
}



Word Ladder - A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:
Every adjacent pair of words differs by a single letter.
Every si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.
sk == endWord
Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.

function ladderLength(beginWord: string, endWord: string, wordList: string[]): number {

//  make the dictionary set from given words    
    const dictionary = new Set(wordList)
    if(!dictionary.has(endWord)){
//  word is not there hence we can't reach it
        return 0
    }

//  now that we have the end word so min steps is 1 if we can reach the end word
    let steps = 1

//  we will do the bfs    
    const wordsQueue = [beginWord]
//  mark the word visited    
    const visited = new Set(wordsQueue)

    while(wordsQueue.length){
        const currLevelSize = wordsQueue.length
        for(let i = 0; i < currLevelSize; i++){
//  remove the first element and return            
            const word = wordsQueue.shift()
            if(word === endWord){
//  found the end word                
                return steps
            }

//  we will try to make new words for next travel
            for(let j = 0; j < word.length; j++){
                for(let k = 0; k < 26; k++){

//  String.fromCharCode(97) gives 'a'
                    const nextWord = word.slice(0, j) 
                                        + String.fromCharCode(97 + k) 
                                        + word.slice(j + 1)

//  add in the queue
                    if(dictionary.has(nextWord) && !visited.has(nextWord)){
                        wordsQueue.push(nextWord)
                        visited.add(nextWord)
                    }
                }
            }
        }
        steps++
    }

//  could not reach the end word
    return 0
};

/* Minimum Genetic Mutation - Given the two gene strings startGene and endGene and the gene bank bank, return the minimum number of mutations needed to mutate from startGene to endGene. If there is no such a mutation, return -1.

Note that the starting point is assumed to be valid, so it might not be included in the bank.
 */
/**
 * @param {string} startGene
 * @param {string} endGene
 * @param {string[]} bank
 * @return {number}
 */
const minMutation = (startGene, endGene, bank) => {
    // Define the valid mutations that can occur
    const validMutations = ['A', 'C', 'G', 'T'];

    // Convert the bank array to a set for faster lookup
    const bankSet = new Set(bank);

    // Check if the end gene is not in the bank, return -1 as it's not possible
    if (!bankSet.has(endGene)) {
        return -1;
    }

    // Set to keep track of visited genes
    const visitedGenes = new Set();

    // Queue for BFS, each element is [gene, mutations]
    const bfsQueue = [[startGene, 0]];

    // Mark the start gene as visited
    visitedGenes.add(startGene);

    // BFS loop
    while (bfsQueue.length > 0) {
        // Dequeue the current gene and its mutations
        const [currGene, mutations] = bfsQueue.shift();

        // Check if the current gene is the end gene
        if (currGene === endGene) {
            // Found the end gene, return the number of mutations
            return mutations;
        }

        // Loop through each character in the current gene
        for (let i = 0; i < currGene.length; i++) {
            // Loop through each valid mutation
            for (let mutationChar of validMutations) {
                // Skip if the current character is the same as the mutation character
                if (currGene[i] === mutationChar) {
                    continue;
                }

                // Create a new gene with the mutation
                const newGene = currGene.slice(0, i) + mutationChar + currGene.slice(i + 1);

                // Check if the new gene is in the bank and has not been visited
                if (bankSet.has(newGene) && !visitedGenes.has(newGene)) {
                    // Found a new valid unvisited gene, enqueue it with mutations + 1
                    bfsQueue.push([newGene, mutations + 1]);
                    // Mark the new gene as visited
                    visitedGenes.add(newGene);
                }
            }
        }
    }

    // If the end gene is not reachable, return -1
    return -1;
};

/* Same tree - Given the roots of two binary trees p and q, write a function to check if they are the same or not.
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
const isSameTree = (p, q) => {
    if (!p && !q) {
        return true
    }
    if ((p && !q) || (!p && q) || (p.val !== q.val)) {
        return false
    }

    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)
};



Deepest leaves sum - Given the root of a binary tree, return the sum of values of its deepest leaves.

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
const deepestLeavesSum = (root) => {

    // solve this using BFS
    // keep tracking the sum and return the last level's

    if (!root) {
        return 0
    }

    const queue = [root]
    let levelSum

    while (queue.length > 0) {
        const currLevelSize = queue.length
        levelSum = 0

        for (let i = 0; i < currLevelSize; i++) {
            const node = queue.shift()
            levelSum += node.val

            if (node.left) {
                queue.push(node.left)
            }
            if (node.right) {
                queue.push(node.right)
            }
        }
    }

    return levelSum
};

/* Shortest Path to Get Food */

// Function to find the minimum steps required to reach food ('#') from the person's starting position ('*') on a 2D grid.
const getFood = grid => {
    // Get the number of rows and columns in the grid
    const rows = grid.length;
    const cols = grid[0].length;
    
    // Find the starting position of the person marked with '*'
    let startX, startY;
    for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
            if (grid[i][j] === '*') {
                startX = i;
                startY = j;
                break;
            }
        }
    }

    // Define the possible directions to move (up, down, left, right)
    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
    
    // Create a set to keep track of visited cells to avoid revisiting them
    const visited = new Set();

    // Function to check if a given position is valid (within the grid boundaries)
    const isValid = (x, y) => x >= 0 && x < rows && y >= 0 && y < cols;

    // Breadth-first search algorithm to find the minimum steps to reach food
    const bfs = () => {
        // Initialize the queue with the starting position and the number of steps taken
        const queue = [[startX, startY, 0]];

        while (queue.length > 0) {
            // Dequeue the current position and steps taken
            const [x, y, steps] = queue.shift();

            // Check if food is found at the current position
            if (grid[x][y] === '#') {
                return steps; // Return the number of steps taken when food is found
            }

            // Explore neighbors in all possible directions
            for (const [dx, dy] of directions) {
                const newX = x + dx;
                const newY = y + dy;

                // Check if the new position is valid and has not been visited before
                if (isValid(newX, newY) && grid[newX][newY] !== 'X' && !visited.has(`${newX}-${newY}`)) {
                    visited.add(`${newX}-${newY}`); // Mark the new position as visited
                    queue.push([newX, newY, steps + 1]); // Enqueue the new position with updated steps
                }
            }
        }

        // Return -1 if no food is found (should not happen if the grid is well-formed)
        return -1;
    };

    // Start BFS to find the minimum steps
    const result = bfs();

    // Return the result, which is either the minimum steps or -1 if no food is found
    return result;
};
