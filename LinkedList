LRUCache - Design a data structure that follows the constraints of a Least Recently Used(LRU) cache.

class LRUCache {

    class DLinkedNode {
        int key;
        int value;
        DLinkedNode next;
        DLinkedNode prev;
}
    
    private int size, capacity;

// 	we will keep head and tail for reference
    private DLinkedNode head, tail;

// 	for each int key, we will keep a node in the map
    private Map < Integer, DLinkedNode > cacheMap = new HashMap <> ();
    
    public LRUCache(int capacity) {
    this.size = 0;
    this.capacity = capacity;

    head = new DLinkedNode();
    tail = new DLinkedNode();

    head.next = tail;
    tail.prev = head;
}
    
    public int get(int key) {
//         get the node from the map
        DLinkedNode node = cacheMap.get(key);
    if (node == null) {
        return -1;
    }

    //         if we find a node then we should move the node to starting of double linked list as per LRU definition
    moveToHead(node);
    return node.value;
}
    
    public void moveToHead(DLinkedNode node){

    // 	remove the node from its current place and add next to head
    removeNode(node);
    addNode(node);
}
    
    public void addNode(DLinkedNode node){

    //         always add the new node right after head
    node.next = head.next;
    node.prev = head;

    head.next.prev = node;
    head.next = node;
}
     
    public void removeNode(DLinkedNode node){
        DLinkedNode prev = node.prev;
        DLinkedNode next = node.next;

    prev.next = next;
    next.prev = prev;
}
    
    public void put(int key, int value) {
        DLinkedNode node = cacheMap.get(key);
    if (node == null) {
            DLinkedNode newNode = new DLinkedNode();
        newNode.key = key;
        newNode.value = value;

        cacheMap.put(key, newNode);
        addNode(newNode);

        size++;

        if (size > capacity) {
//                 remove the last node in double linked list
                DLinkedNode tail = popTail();
            cacheMap.remove(tail.key);
            size--;
        }
    } else {

        // 	if node already exists then simply move next to head
        node.value = value;
        moveToHead(node);
    }
}
    
    public DLinkedNode popTail(){
//         remove the node before tail as tail and head are for reference
        DLinkedNode nodeToRemove = tail.prev;
    removeNode(nodeToRemove);
    return nodeToRemove;
}
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */

/* Add Two Numbers - You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.
 */
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
const addTwoNumbers = (l1, l2) => {
    const dummyHead = new ListNode(0); // Create a dummy node to simplify code
    let currentNode = dummyHead;
    let carry = 0;

    while (l1 || l2 || carry) {
        const sum = (l1 ? l1.val : 0) + (l2 ? l2.val : 0) + carry;
        carry = Math.floor(sum / 10);

        currentNode.next = new ListNode(sum % 10);
        currentNode = currentNode.next;

        if (l1) {
            l1 = l1.next;
        }
        if (l2) {
            l2 = l2.next;
        }
    }

    return dummyHead.next;
};

/* Odd Even Linked List - Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.
 */
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
const oddEvenList = (head) => {
    if (!head) {
        return head
    }
    let oddNode = head
    let evenNode = head.next
    let evenHead = head.next

    while (evenNode !== null && evenNode.next !== null) {
        //  keep connecting odd ones to each other
        oddNode.next = evenNode.next
        oddNode = oddNode.next
        //  keep connecting even ones to each other
        evenNode.next = oddNode.next
        evenNode = evenNode.next
    }
    //  all even nodes are on the right side now
    oddNode.next = evenHead

    return head
};


/* Reorder List - You are given the head of a singly linked-list. The list can be represented as:

L0 → L1 → … → Ln - 1 → Ln
Reorder the list to be on the following form:

L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
You may not modify the values in the list's nodes. Only nodes themselves may be changed.
 */
/**
 * Example:
 * var li = ListNode(5)
 * var v = li.`val`
 * Definition for singly-linked list.
 * class ListNode(var `val`: Int) {
 *     var next: ListNode? = null
 * }
 */
const reorderList = (head) => {
    // Initialize a stack to store nodes
    const stack = [];
    // Initialize a variable 'node' to the head of the linked list
    let node = head;

    // Check if the linked list is empty
    if (!node) {
        return;
    }

    // Traverse the linked list and push each node onto the stack
    while (node) {
        stack.push(node);
        node = node.next;
    }

    // Get the length of the stack (number of nodes in the linked list)
    const length = stack.length;
    // Reset 'node' to the head of the linked list
    node = head;

    // Reorder the linked list by alternating between popping and shifting nodes
    for (let i = 0; i < length; i++) {
        // If the current index is even, connect the current node to the node at the front of the stack
        if (i % 2 === 0) {
            node.next = stack.shift();
        } else {
            // If the current index is odd, connect the current node to the node at the end of the stack
            node.next = stack.pop();
        }
        // Move to the next node in the linked list
        node = node.next;
    }

    // Set the 'next' pointer of the last node to null to terminate the reordered list
    node.next = null;
};

/* Flatten a Multilevel Doubly Linked List - Given the head of the first level of the list, flatten the list so that all the nodes appear in a single-level, doubly linked list. Let curr be a node with a child list. The nodes in the child list should appear after curr and before curr.next in the flattened list.

Return the head of the flattened list. The nodes in the list must have all of their child pointers set to null.
 */
/**
 * // Definition for a Node.
 * function Node(val,prev,next,child) {
 *    this.val = val;
 *    this.prev = prev;
 *    this.next = next;
 *    this.child = child;
 * };
 */

/**
 * @param {Node} head
 * @return {Node}
 */
const flatten = (head) => {
    const flattenDFS = (prev, curr) => {
        if (!curr) {
            //  prev is the tail
            return prev
        }

        //  establish links
        curr.prev = prev
        prev.next = curr

        //  this will be needed after flattening
        const tempNext = curr.next

        //  find the tail of flattened children
        const tail = flattenDFS(curr, curr.child)

        //  remove the child
        curr.child = null

        //  establish the pointers and travel further
        return flattenDFS(tail, tempNext)
    }

    if (!head) {
        return head
    }

    const temp = new Node(-1)
    temp.next = head
    flattenDFS(temp, head)

    //  remove the temp pointer
    temp.next.prev = null

    return temp.next
};

/* Linked List Cycle - Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null. */

/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
const detectCycle = (head) => {
    //  we will take a slow pointer and a fast pointer moving with double speed
    //  metNode is where these two pointers meet
    //  we will start two pointers; one from head another from meetPoint and where these two meet is the start of cycle

    if (!head) {
        return head
    }

    let slowNode = head
    let fastNode = head

    while (fastNode?.next) {
        slowNode = slowNode.next
        fastNode = fastNode.next.next

        if (slowNode === fastNode) {
            break
        }
    }

    if (!fastNode?.next) {
        //  no cycle
        return null
    }

    slowNode = head
    while (slowNode != fastNode) {
        slowNode = slowNode.next
        fastNode = fastNode.next
    }

    return slowNode
};

/* Palindrome Linked List - Given the head of a singly linked list, return true if it is a 
palindrome or false otherwise.
 */
/**
 * Example:
 * var li = ListNode(5)
 * var v = li.`val`
 * Definition for singly-linked list.
 * class ListNode(var `val`: Int) {
 *     var next: ListNode? = null
 * }
 */
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {boolean}
 */
const isPalindrome = (head) => {
    let currNode = head
    let isPalindrome = true
    const moveToEnd = (node) => {
        if (node) {
            moveToEnd(node.next)

            if (node.val !== currNode.val) {
                isPalindrome = false
            }
            currNode = currNode.next
        }
    }
    moveToEnd(head)

    return isPalindrome
};

/* Merge k Sorted Lists - You are given an array of k linked - lists lists, each linked - list is sorted in ascending order.

Merge all the linked - lists into one sorted linked - list and return it.
 */
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
const mergeKLists = (lists) => {

    //  we will solve this using min heap
    const minHeap = new MinHeap()

    //  push the heads of each list in the heap
    for (const head of lists) {
        if (head) {
            minHeap.push(head)
        }
    }

    const dummy = new ListNode()
    let currNode = dummy

    while (!minHeap.isEmpty()) {
        //  pop the node from minHeap with smallest value
        const node = minHeap.pop()

        currNode.next = node
        currNode = currNode.next

        //  move to the next node of this list
        if (node.next) {
            minHeap.push(node.next)
        }
    }

    // return the head of final sorted list
    return dummy.next
};

class MinHeap {
    constructor() {
        this.heap = []
    }

    push(node) {
        this.heap.push(node)
        this.heapifyUp()
    }

    pop() {
        if (this.isEmpty()) {
            return null
        }

        const root = this.heap[0]
        const lastNode = this.heap.pop()

        if (this.heap.length > 0) {
            this.heap[0] = lastNode
            this.heapifyDown()
        }

        return root
    }

    isEmpty() {
        return this.heap.length === 0
    }

    heapifyUp() {
        let index = this.heap.length - 1

        while (index > 0) {
            const parentIndex = Math.floor((index - 1) / 2)
            if (this.heap[index].val < this.heap[parentIndex].val) {
                this.swap(index, parentIndex)
                index = parentIndex
            } else {
                break
            }
        }
    }

    heapifyDown() {
        let index = 0;
        const length = this.heap.length;

        while (true) {
            const leftChildIndex = 2 * index + 1;
            const rightChildIndex = 2 * index + 2;
            let smallestChildIndex = index;

            if (leftChildIndex < length && this.heap[leftChildIndex].val < this.heap[smallestChildIndex].val) {
                smallestChildIndex = leftChildIndex;
            }

            if (rightChildIndex < length && this.heap[rightChildIndex].val < this.heap[smallestChildIndex].val) {
                smallestChildIndex = rightChildIndex;
            }

            if (smallestChildIndex !== index) {
                this.swap(index, smallestChildIndex);
                index = smallestChildIndex;
            } else {
                break;
            }
        }
    }

    swap(i, j) {
        const temp = this.heap[i];
        this.heap[i] = this.heap[j];
        this.heap[j] = temp;
    }
}



Insert greatest common divisors - Given the head of a linked list head, in which each node contains an integer value.

Between every pair of adjacent nodes, insert a new node with a value equal to the greatest common divisor of them.

/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
const insertGreatestCommonDivisors = (head) => {
    let currNode = head

    while (currNode && currNode.next) {
        const gcd = findGCD(currNode.val, currNode.next.val)

        const gcdNode = new ListNode(gcd)
        gcdNode.next = currNode.next
        currNode.next = gcdNode

        currNode = gcdNode.next
    }

    return head
};

const findGCD = (a, b) => {
    while (b !== 0) {
        const temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}



Nested List Weight Sum - Given a nested list of integers, return the sum of all integers in the list weighted by their depth.

Each element is either an integer, or a list-- whose elements may also be integers or other lists.

const depthSum = (nestedList) => {
    const dfs = (nestedList, depth) => {
        let totalSum = 0;

        for (let element of nestedList) {
            //  check for nesting
            if (Array.isArray(element)) {
                //  get the sum of this list
                totalSum += dfs(element, depth + 1);
            } else {
                //  add weighted sum
                totalSum += element * depth;
            }
        }

        return totalSum;
    }

    return dfs(nestedList, 1);
}



Max twin sum of a linked list - Given the head of a linked list with even length, return the maximum twin sum of the linked list.

/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {number}
 */
const pairSum = (head) => {
    let maxTwinSum = 0
    let leftPointer = head
    const countSum = (node) => {
        if (!node || node.next === leftPointer) {
            return
        }
        //  move the node to end first
        countSum(node.next)
        const currTwinSum = leftPointer.val + node.val
        maxTwinSum = Math.max(currTwinSum, maxTwinSum)

        //  keep moving forward as the node moves backward
        leftPointer = leftPointer.next
    }
    countSum(head)
    return maxTwinSum
};

/* Delete node in a linked list - Head is not given
 */
const deleteNode = (node) => {
    if (node) {
        //  take the value of next node
        node.val = node.next.val
        //  skip next node
        node.next = node.next.next
    }
};

/* Spiral matrix - You are given two integers m and n, which represent the dimensions of a matrix.

You are also given the head of a linked list of integers.

Generate an m x n matrix that contains the integers in the linked list presented in spiral order (clockwise), starting from the top-left of the matrix. If there are remaining empty spaces, fill them with -1.

Return the generated matrix.
 */
const spiralMatrix = (m, n, head) => {
    let currRow = 0
    let currCol = 0

    let top = 1, right = n - 1, bottom = m - 1, left = 0

    let direction = 'r'

    //  -1 by default
    const mat = new Array(m).fill().map(() => new Array(n).fill(-1))

    //  iterate till linked list finishes
    while (head) {
        mat[currRow][currCol] = head.val

        //  reached right
        if (currCol === right && direction === 'r') {
            right--
            direction = 'd'
        }
        //  reached bottom
        if (currRow === bottom && direction === 'd') {
            bottom--
            direction = 'l'
        }
        //  reached left
        if (currCol === left && direction === 'l') {
            left++
            direction = 'u'
        }
        //  reached top
        if (currRow === top && direction === 'u') {
            top++
            direction = 'r'
        }

        //  handle moving pointers
        if (direction === 'r') currCol++
        if (direction === 'd') currRow++
        if (direction === 'l') currCol--
        if (direction === 'u') currRow--

        head = head.next
    }

    return mat
};


/* Merge Nodes in Between Zeros - You are given the head of a linked list, which contains a series of integers separated by 0's. The beginning and end of the linked list will have Node.val == 0.

For every two consecutive 0's, merge all the nodes lying in between them into a single node whose value is the sum of all the merged nodes. The modified list should not contain any 0's.

Return the head of the modified linked list.
 */
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
const mergeNodes = (head) => {

    //  we will use two pointers approach

    //  use this to keep track of the head
    let start = head

    //  this node will move
    let currNode = head

    //  this node is used to skip current nodes
    let prev = currNode

    while (currNode) {
        if (currNode.val === 0) {
            //  skip the 0 node
            prev.next = currNode.next
        } else {
            while (currNode.next.val !== 0) {
                //  pass the values 
                currNode.next.val = currNode.next.val + currNode.val

                //  skip the current node
                prev.next = currNode.next
                currNode = currNode.next
            }
            //  node before the 0 node
            prev = currNode
        }
        currNode = currNode.next
    }

    //  first node was 0
    return start.next
};

/* Swap nodes in pairs - Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)
 */

/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var swapPairs = function (head) {
    if (head && head.next) {

        //  temp node to track the head
        const ans = new ListNode(0)
        ans.next = head

        //  moving pointer
        let curr = ans
        while (curr.next && curr.next.next) {
            //  nodes to swap
            let node1 = curr.next
            let node2 = curr.next.next

            curr.next = node2
            node1.next = node2.next
            node2.next = node1

            //  skip one node
            curr = curr.next.next
        }
        return ans.next
    }
    return head
};

/* Remove Nth Node From End of List - Given the head of a linked list, remove the nth node from the end of the list and return its head.
 */

/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
const removeNthFromEnd = (head, n) => {
    // Initialize two pointers, fast and slow, both pointing to the head of the linked list
    let fast = head, slow = head;

    // Move the fast pointer n nodes ahead
    for (let i = 0; i < n; i++) {
        fast = fast.next;
    }

    // If fast becomes null, it means we need to remove the head of the linked list
    // Return head.next in this case
    if (!fast) {
        return head.next;
    }

    // Move both fast and slow pointers until fast reaches the end of the linked list
    while (fast.next) {
        fast = fast.next;
        slow = slow.next;
    }

    // Now, slow is pointing to the node just before the one to be removed
    // Adjust the pointers to skip the node to be removed
    slow.next = slow.next.next;

    // Return the head of the modified linked list
    return head;
};