/* Number of islands - Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.
 */
/**
 * @param {character[][]} grid
 * @return {number}
 */
const numIslands = (grid) => {
    let ans = 0

    const dfs = (grid, row, col) => {
        const rows = grid.length
        const cols = grid[0].length

        if (row < 0 || row >= rows || col < 0 || col >= cols || grid[row][col] === '0') {
            return
        }

        //  mark as visited if there is a connecting 1 because that's the part of the same island
        grid[row][col] = '0'

        //  find other 1s and mark them visited
        dfs(grid, row, col - 1)
        dfs(grid, row, col + 1)
        dfs(grid, row + 1, col)
        dfs(grid, row - 1, col)
    }

    if (grid && grid.length) {
        const rows = grid.length
        const cols = grid[0].length

        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                if (grid[row][col] === '1') {
                    //  the moment we find a '1' automatically there is atleast one island
                    //  because other connecting 1s are marked as 0 or visited. 
                    //  Connected 1s are
                    //  counted as 1 island
                    ans++
                    dfs(grid, row, col)
                }
            }
        }
    }

    return ans
};

/* Maximum Product of Splitted Binary Tree - Given the root of a binary tree, split the binary tree into two subtrees by removing one edge such that the product of the sums of the subtrees is maximized.

Return the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo 109 + 7.

Note that you need to maximize the answer before taking the mod and not after taking it.
 */
/**
 * Example:
 * var ti = TreeNode(5)
 * var v = ti.`val`
 * Definition for a binary tree node.
 * class TreeNode(var `val`: Int) {
 *     var left: TreeNode? = null
 *     var right: TreeNode? = null
 * }
 */

class Solution {
    
    fun maxProduct(root: TreeNode?): Int {

        //  first we need to find the total sum of the tree
        //  the at any node we need to find the sum of subtree with this node as the root
        //  keep maintaining the maxProduct found so far

        var sumOfGivenTree = 0
        var maxProduct = 0L
        
        fun sumTree(node: TreeNode ?): Int{
            if (node == null) {
                return 0
            }

            return sumTree(node.left) + sumTree(node.right) + node.`val`
        }

        fun dfs(node: TreeNode ?): Long{
            if (node == null) {
                return 0L
            }

            val currTreeSum = dfs(node.left) + dfs(node.right) + node.`val`

//  if we break the edge at this node then product will be as given below
            val productAtCurrNode = currTreeSum * (sumOfGivenTree - currTreeSum)

            maxProduct = maxOf(maxProduct, productAtCurrNode)

            return currTreeSum
        }

        sumOfGivenTree = sumTree(root)
        dfs(root)

        return (maxProduct % 1000000007).toInt()
    }
}

/* Maximum Difference Between Node and Ancestor - Given the root of a binary tree, find the maximum value v for which there exist different nodes a and b where v = |a.val - b.val| and a is an ancestor of b.

A node a is an ancestor of b if either: any child of a is equal to b or any child of a is an ancestor of b.
 */
const maxAncestorDiff = (root) => {
    let maxDiff = 0

    const findDiff = (node, maxSoFar, minSoFar) => {
        //  notice that max and min are coming from the ancestors
        if (node) {
            maxSoFar = Math.max(maxSoFar, node.val)
            minSoFar = Math.min(minSoFar, node.val)

            maxDiff = Math.max(maxSoFar - minSoFar, maxDiff)

            findDiff(node.left, maxSoFar, minSoFar)
            findDiff(node.right, maxSoFar, minSoFar)
        }
    }
    findDiff(root, root.val, root.val)

    return maxDiff
};

/* Number of Nodes in the Sub-Tree With the Same Label - You are given a tree (i.e. a connected, undirected graph that has no cycles) consisting of n nodes numbered from 0 to n - 1 and exactly n - 1 edges. The root of the tree is the node 0, and each node of the tree has a label which is a lower-case character given in the string labels (i.e. The node with the number i has the label labels[i]).

The edges array is given on the form edges[i] = [ai, bi], which means there is an edge between nodes ai and bi in the tree.

Return an array of size n where ans[i] is the number of nodes in the subtree of the ith node which have the same label as node i.
 */
/**
 * @param {number} n
 * @param {number[][]} edges
 * @param {string} labels
 * @return {number[]}
 */
const countSubTrees = (n, edges, labels) => {
    // Create an adjacency list to represent the undirected graph
    const adjList = Array.from(Array(n), () => new Array())

    // Create the undirected graph
    for (const [from, to] of edges) {
        adjList[from].push(to)
        adjList[to].push(from)
    }

    // Initialize an array to store the result for each node
    const ans = Array(n).fill(0)

    // Initialize an array to count the occurrences of each character in the subtree
    const count = Array(26).fill(0)

    // Depth-first search (DFS) function to traverse the tree
    const dfs = (node, parent, pcount) => {
        // Initialize an array to count the occurrences of each character in the current subtree
        const count = Array(26).fill(0)

        // Traverse each neighbor of the current node
        for (const neighbour of adjList[node]) {
            // Skip the parent node to avoid revisiting it
            if (neighbour === parent) {
                continue
            }

            // Recursively call DFS for the current neighbor
            dfs(neighbour, node, count)
        }

        // Increment the count for the character at the current node
        count[labels.charCodeAt(node) - 97]++
        ans[node] = count[labels.charCodeAt(node) - 97]

        // Update the parent count array with the counts from the current subtree
        for (let i = 0; i < 26; i++) {
            pcount[i] += count[i]
        }
    }

    // Start DFS from the root node (node 0) with a dummy parent (-1) and initial count array
    dfs(0, -1, count)

    // Return the result array
    return ans
};

/* Validate Binary Search Tree - Given the root of a binary tree, determine if it is a valid binary search tree (BST).

A valid BST is defined as follows:
The left subtree of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.
 */
/**
 * Example:
 * var ti = TreeNode(5)
 * var v = ti.`val`
 * Definition for a binary tree node.
 * class TreeNode(var `val`: Int) {
 *     var left: TreeNode? = null
 *     var right: TreeNode? = null
 * }
 */
class Solution {
    var prevValue: Int?= null

    fun isValidBST(root: TreeNode ?): Boolean {
    //  we will do inorder traversal of the tree 

    return dfs(root)
}

    fun dfs(currNode: TreeNode ?): Boolean{
    if (currNode == null) {
        //  empty tree is a valid BST            
        return true
    }

    if (!dfs(currNode.left)) {
        return false
    }

    if (prevValue != null && currNode.`val` <= prevValue as Int) {
        //  equal member will be on the right of a node in BST
        return false
    }

    prevValue = currNode.`val`

    return dfs(currNode.right)
}
}

/* Course Schedule - There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.

For example, the pair[0, 1], indicates that to take course 0 you have to first take course 1.
Return true if you can finish all courses.Otherwise, return false.
 */
/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {number[]}
 */
// Function to find the order of courses
const findOrder = (numCourses, prerequisites) => {
    // Array to store the in-degrees of each course
    const inDegrees = Array(numCourses).fill(0);

    // Count the in-degrees for each course based on prerequisites
    for (const [v, u] of prerequisites) {
        //  can come to v from course u
        inDegrees[v]++;
    }

    // Queue to store courses with in-degree 0 (can be taken first)
    const q = [];

    // Add courses with in-degree 0 to the queue
    for (let i = 0; i < inDegrees.length; i++) {
        const degree = inDegrees[i];
        if (degree === 0) {
            q.push(i);
        }
    }

    // Array to store the final result (order of courses)
    const res = [];

    // Process courses in topological order
    while (q.length) {
        // Take a course with in-degree 0 from the queue
        const u0 = q.shift();

        // Decrement the total number of courses remaining
        numCourses--;

        // Add the course to the result
        res.push(u0);

        // Update in-degrees for courses dependent on the current course
        for (const [v, u] of prerequisites) {
            if (u === u0) {
                inDegrees[v]--;

                // If the in-degree becomes 0, add the course to the queue
                if (inDegrees[v] === 0) {
                    q.push(v);
                }
            }
        }
    }

    // If all courses can be taken, return the result; otherwise, return an empty array
    return numCourses === 0 ? res : [];
};

/* Most Stones Removed with Same Row or Column - On a 2D plane, we place n stones at some integer coordinate points.Each coordinate point may have at most one stone.
A stone can be removed if it shares either the same row or the same column as another stone that has not been removed.
Given an array stones of length n where stones[i] = [xi, yi] represents the location of the ith stone, return the largest possible number of stones that can be removed.
 */
/**
 * @param {number[][]} stones
 * @return {number}
 */
const removeStones = (stones) => {
    //  use DFS
    const visited = new Set()
    let stoneGroups = 0

    const traverse = (x, y) => {
        const key = `${x}_${y}`
        if (!visited.has(key)) {
            visited.add(key)
            for (const [newX, newY] of stones) {
                if (newX === x || newY === y) {
                    traverse(newX, newY)
                }
            }
        }
    }

    for (const [x, y] of stones) {
        const key = `${x}_${y}`
        if (!visited.has(key)) {
            traverse(x, y)
            stoneGroups++
        }
    }

    return stones.length - stoneGroups
};

/* Find Closest Node to Given Two Nodes - You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.

The graph is represented with a given 0 - indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i].If there is no outgoing edge from i, then edges[i] == -1.

You are also given two integers node1 and node2.

Return the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized.If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.

Note that edges may contain cycles.
 */
class Solution {

    fun closestMeetingNode(edges: IntArray, node1: Int, node2: Int): Int {
        val numEdges = edges.size

//  store shortest distances of all the reachable nodes from both given nodes
        val distOneArray = IntArray(numEdges){ Int.MAX_VALUE }
        distOneArray[node1] = 0
        val distTwoArray = IntArray(numEdges){ Int.MAX_VALUE }
        distTwoArray[node2] = 0

        //  fill the distances of all nodes from given two nodes
        fillDistances(node1, edges, distOneArray, BooleanArray(numEdges){ false})
        fillDistances(node2, edges, distTwoArray, BooleanArray(numEdges){ false})

        var minDistNode = -1
        var minDistanceTillNow = Int.MAX_VALUE
        for (currNode in 0 until numEdges) {
            if (minDistanceTillNow > maxOf(distOneArray[currNode], distTwoArray[currNode])) {
                //  record the node which is closer to both                
                minDistNode = currNode
                minDistanceTillNow = maxOf(distOneArray[currNode], distTwoArray[currNode])
            }
        }

        return minDistNode
    }

    fun fillDistances(currNode: Int, edges: IntArray, distArray: IntArray,
        visitArray: BooleanArray) {
        visitArray[currNode] = true
        val neighbor = edges[currNode]
        if (neighbor != -1 && !visitArray[neighbor]) {
            //  see if the neighbor is not visited
            distArray[neighbor] = 1 + distArray[currNode]
            fillDistances(neighbor, edges, distArray, visitArray)
        }
    }
}

/* All Nodes Distance K in Binary Tree - Given the root of a binary tree, the value of a target node target, and an integer k, return an array of the values of all nodes that have a distance k from the target node.
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} target
 * @param {number} k
 * @return {number[]}
 */
const distanceK = (root, target, k) => {
    if (!root) {
        return
    }

    const findTarget = (node, parent, target) => {
        if (node) {
            node.parent = parent
            if (node == target) {
                return node
            }
            return findTarget(node.left, node, target) || findTarget(node.right, node, target)
        }
    }

    //  find the target and assign a parent to each node
    const targetNode = findTarget(root, null, target)

    const res = []

    const findAllKApart = (node, k, res) => {
        if (!node || node.visited) {
            return res
        }

        if (k === 0) {
            //  reached the end
            res.push(node.val)
            return res
        }

        //  mark
        node.visited = true

        //  travel in all directions
        findAllKApart(node.left, k - 1, res)
        findAllKApart(node.right, k - 1, res)
        findAllKApart(node.parent, k - 1, res)

        return res
    }

    //  start the travel from target node and keep marking visited
    findAllKApart(targetNode, k, res)

    return res
};






Sum of nodes with even valued grandparent - Given the root of a binary tree, return the sum of values of nodes with an even - valued grandparent.If there are no nodes with an even - valued grandparent, return 0.

const sumEvenGrandparent = (root) => {

    //  visit each node and maintain the parent and gparent

    let sum = 0

    const dfs = (node, parent, gparent) => {
        if (node) {
            if (gparent && gparent.val % 2 === 0) {
                sum += node.val
            }
            dfs(node.left, node, parent)
            dfs(node.right, node, parent)
        }
    }
    dfs(root, null, null)

    return sum

};



Battleships in a board - Given an m x n matrix board where each cell is a battleship 'X' or empty '.', return the number of the battleships on board.

Battleships can only be placed horizontally or vertically on board.In other words, they can only be made of the shape 1 x k(1 row, k columns) or k x 1(k rows, 1 column), where k can be of any size.At least one horizontal or vertical cell separates between two battleships(i.e., there are no adjacent battleships).

/**
 * @param {character[][]} board
 * @return {number}
 */
const countBattleships = (board) => {

    //  solve using DFS

    let ships = 0

    const clearAdjacent = (board, row, col) => {
        if (row < 0 || row >= board.length || col < 0 || col >= board[row].length
            || board[row][col] === '.') {
            return
        }

        board[row][col] = '.'

        clearAdjacent(board, row + 1, col)
        clearAdjacent(board, row - 1, col)
        clearAdjacent(board, row, col + 1)
        clearAdjacent(board, row, col - 1)
    }

    //  visit each cell and mark adjacent cells
    for (let row = 0; row < board.length; row++) {
        for (let col = 0; col < board[row].length; col++) {
            if (board[row][col] === 'X') {
                //  found a ship as per def
                ships++
                clearAdjacent(board, row, col)
            }
        }
    }

    return ships
};


Find eventual safe states - There is a directed graph of n nodes with each node labeled from 0 to n - 1. The graph is represented by a 0 - indexed 2D integer array graph where graph[i] is an integer array of nodes adjacent to node i, meaning there is an edge from node i to each node in graph[i].

A node is a terminal node if there are no outgoing edges.A node is a safe node if every possible path starting from that node leads to a terminal node(or another safe node).

Return an array containing all the safe nodes of the graph.The answer should be sorted in ascending order.

/**
 * @param {number[][]} graph
 * @return {number[]}
 */
const eventualSafeNodes = (graph) => {
    const ans = [];
    const map = new Map();
    const dfs = (graph, node, map) => {
        if (map.has(node)) {
            return map.get(node);
        }
        //  this will help find circular or unsafe nodes
        map.set(node, false);

        //  check all the neighbors
        for (let nei of graph[node]) {
            if (!dfs(graph, nei, map)) {
                //  this neighbor is not safe
                return false;
            }
        }

        //  all the neighbors are safe
        map.set(node, true);
        return true;
    }
    for (let i = 0; i < graph.length; i++) {
        if (dfs(graph, i, map)) {
            ans.push(i);
        }
    }
    return ans;
};

/* Max area of island - You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.

The area of an island is the number of cells with a value 1 in the island.

Return the maximum area of an island in grid. If there is no island, return 0.
 */
/**
 * @param {number[][]} grid
 * @return {number}
 */
const maxAreaOfIsland = (grid) => {
    const ROWS = grid.length
    const COLUMNS = grid[0].length

    const DFS = (row, column) => {
        //  we will store indices in this stack
        const stack = [[row, column]];
        let currRow, currColumn, resultArea = 0;
        while (stack.length !== 0) {
            [currRow, currColumn] = stack.pop();
            if (grid[currRow][currColumn] !== 1)
                continue;

            //  stop duplication
            grid[currRow][currColumn] = 2;

            //  found further land
            resultArea++;

            //  explore 4 directions
            if (currRow + 1 < ROWS)
                stack.push([currRow + 1, currColumn]);
            if (currRow - 1 >= 0)
                stack.push([currRow - 1, currColumn]);
            if (currColumn + 1 < COLUMNS)
                stack.push([currRow, currColumn + 1]);
            if (currColumn - 1 >= 0)
                stack.push([currRow, currColumn - 1]);
        }
        return resultArea;
    };

    let maxArea = 0

    //  visit each cell
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLUMNS; c++) {
            if (grid[r][c] === 1) {
                maxArea = Math.max(maxArea, DFS(r, c))
            }
        }
    }
    return maxArea
};

/* Rotting oranges - You are given an m x n grid where each cell can have one of three values:

- 0 representing an empty cell,
- 1 representing a fresh orange, or
- 2 representing a rotten orange.

Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.

Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.
 */

/**
 * @param {number[][]} grid
 * @return {number}
 */
const orangesRotting = (grid) => {
    // Get the number of rows and columns in the grid
    const ROWS = grid.length
    const COLS = grid[0].length

    // Depth First Search (DFS) function to explore adjacent cells
    const dfs = (r, c, grid, mins) => {
        // Base cases to stop recursion
        if (r < 0 || r >= ROWS || c < 0 || c >= COLS
            || grid[r][c] === 0 || (grid[r][c] > 1 && grid[r][c] < mins)) {
            return
        }

        // Mark the cell with the current time (minutes)
        grid[r][c] = mins

        // Explore adjacent cells in four directions
        dfs(r + 1, c, grid, mins + 1)
        dfs(r - 1, c, grid, mins + 1)
        dfs(r, c + 1, grid, mins + 1)
        dfs(r, c - 1, grid, mins + 1)
    }

    // Starting time for rotten oranges
    let mins = 2

    // Iterate over the grid to find initially rotten oranges and start DFS
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            if (grid[r][c] === 2) {
                dfs(r, c, grid, mins)
            }
        }
    }

    // Check if there are any fresh oranges left or find the maximum time for all cells
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            if (grid[r][c] === 1) {
                // If there are fresh oranges left, return -1 (impossible to rot all oranges)
                return -1
            }
            // Update the maximum time encountered so far
            mins = Math.max(mins, grid[r][c])
        }
    }

    // Return the time taken to rot all oranges (subtract 2 to get the actual time)
    return mins - 2
};