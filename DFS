Number of islands - Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

class Solution {
    public int numIslands(char[][] grid) {
        if(grid == null || grid.length == 0){
            return 0;
        }
        
        int numRows = grid.length;
        int numColumns = grid[0].length;
        
        int numIslands = 0;
        
        for(int row = 0; row < numRows; row++){
            for(int column = 0; column < numColumns; column++){
                if(grid[row][column] == '1'){
//                     the moment we find a '1' automatically there is atleast one island
//                     because other connecting 1s are marked as 0 or visited. Connected 1s are
//                     counted as 1 island
                    numIslands++;
                    dfs(grid, row, column);
                }
            }
        }
        
        return numIslands;
    }
    
    public void dfs(char[][] grid, int row, int column){
        int numRows = grid.length;
        int numColumns = grid[0].length;
        
        if(row < 0 || row >= numRows || column < 0 || column >= numColumns 
           || grid[row][column] == '0'){
            return;
        }
        
//         mark as visited if there is a connecting 1 because that's the part of the same island
        grid[row][column] = '0';
        
//         find other 1s and mark them visited
        dfs(grid, row - 1, column);
        dfs(grid, row + 1, column);
        dfs(grid, row, column - 1);
        dfs(grid, row, column + 1);
    }
}




Maximum Product of Splitted Binary Tree - Given the root of a binary tree, split the binary tree into two subtrees by removing one edge such that the product of the sums of the subtrees is maximized.

Return the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo 109 + 7.

Note that you need to maximize the answer before taking the mod and not after taking it.

/**
 * Example:
 * var ti = TreeNode(5)
 * var v = ti.`val`
 * Definition for a binary tree node.
 * class TreeNode(var `val`: Int) {
 *     var left: TreeNode? = null
 *     var right: TreeNode? = null
 * }
 */

class Solution {
    
    fun maxProduct(root: TreeNode?): Int {

//  first we need to find the total sum of the tree
//  the at any node we need to find the sum of subtree with this node as the root
//  keep maintaining the maxProduct found so far

        var sumOfGivenTree = 0
        var maxProduct = 0L
        
        fun sumTree(node: TreeNode?): Int{
            if(node == null){
                return 0
            }

            return sumTree(node.left) + sumTree(node.right) + node.`val`
        }

        fun dfs(node: TreeNode?): Long{
            if(node == null){
                return 0L
            }

            val currTreeSum = dfs(node.left) + dfs(node.right) + node.`val` 

//  if we break the edge at this node then product will be as given below
            val productAtCurrNode = currTreeSum * (sumOfGivenTree - currTreeSum)

            maxProduct = maxOf(maxProduct, productAtCurrNode) 

            return currTreeSum
        }

        sumOfGivenTree = sumTree(root)
        dfs(root)

        return (maxProduct % 1000000007).toInt()
    }
}



Maximum Difference Between Node and Ancestor - Given the root of a binary tree, find the maximum value v for which there exist different nodes a and b where v = |a.val - b.val| and a is an ancestor of b.

A node a is an ancestor of b if either: any child of a is equal to b or any child of a is an ancestor of b.

const maxAncestorDiff = (root) => {
    let maxDiff = 0

    const findDiff = (node, maxSoFar, minSoFar) => {
        //  notice that max and min are coming from the ancestors
        if (node) {
            maxSoFar = Math.max(maxSoFar, node.val)
            minSoFar = Math.min(minSoFar, node.val)

            maxDiff = Math.max(maxSoFar - minSoFar, maxDiff)

            findDiff(node.left, maxSoFar, minSoFar)
            findDiff(node.right, maxSoFar, minSoFar)
        }
    }
    findDiff(root, root.val, root.val)

    return maxDiff
};


Number of Nodes in the Sub-Tree With the Same Label - You are given a tree (i.e. a connected, undirected graph that has no cycles) consisting of n nodes numbered from 0 to n - 1 and exactly n - 1 edges. The root of the tree is the node 0, and each node of the tree has a label which is a lower-case character given in the string labels (i.e. The node with the number i has the label labels[i]).

The edges array is given on the form edges[i] = [ai, bi], which means there is an edge between nodes ai and bi in the tree.

Return an array of size n where ans[i] is the number of nodes in the subtree of the ith node which have the same label as node i.

class Solution {
    fun countSubTrees(numNodes: Int, edges: Array<IntArray>, labels: String): IntArray {
//  we have to count the number of nodes with the same label as the parent for all subtrees

//  starting node is 0 and parent is NA or -1 
        val node = 0
        val parent = -1

        val adjList = Array(numNodes){ mutableListOf<Int>() }
//  for each node we will maintain what all nodes this node is connected to
        for(edge in edges){
            adjList[edge[0]].add(edge[1])
            adjList[edge[1]].add(edge[0])
        }

//  for each node i the number of child nodes with the same label
        var resultArr = IntArray(numNodes)

        dfs(node, parent, adjList, labels, resultArr)

        return resultArr
    }

    fun dfs(node: Int, parent: Int, adjList: Array<MutableList<Int>>, 
                labels: String, resultArr: IntArray): IntArray{
        val allCharsCountArray = IntArray(26)
        val currNodeLabelInNum = labels[node] - 'a'

//  we will traverse the subtree and keep the count of all the labels we find
//  start the count with parent's label
        allCharsCountArray[currNodeLabelInNum]++

//  traverse the subtree - all childs
        for(child in adjList[node]){
            if(child == parent){
//  already counted
                continue
            }
            
            val childSubtreeLabelsCount = dfs(child, node, adjList, labels, resultArr)
            
            for(counter in 0..25){
//  we found the labels in child subtree and add those numbers in the current node's numbers                
                allCharsCountArray[counter] += childSubtreeLabelsCount[counter]
            }
        }

//  record the numbers - notice this is coming from bottom to top hence the highest number found so far
        resultArr[node] = allCharsCountArray[currNodeLabelInNum]

//  return the array to parent
        return allCharsCountArray
    }
}



Validate Binary Search Tree - Given the root of a binary tree, determine if it is a valid binary search tree (BST).

A valid BST is defined as follows:
The left subtree of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.

/**
 * Example:
 * var ti = TreeNode(5)
 * var v = ti.`val`
 * Definition for a binary tree node.
 * class TreeNode(var `val`: Int) {
 *     var left: TreeNode? = null
 *     var right: TreeNode? = null
 * }
 */
class Solution {
    var prevValue: Int? = null

    fun isValidBST(root: TreeNode?): Boolean {
//  we will do inorder traversal of the tree 

        return dfs(root)
    }

    fun dfs(currNode: TreeNode?): Boolean{
        if(currNode == null){
//  empty tree is a valid BST            
            return true
        }

        if(!dfs(currNode.left)){
            return false
        }

        if(prevValue != null && currNode.`val` <= prevValue as Int){
//  equal member will be on the right of a node in BST
            return false
        }

        prevValue = currNode.`val`

        return dfs(currNode.right)
    }
}



Course Schedule - There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.

For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.
Return true if you can finish all courses. Otherwise, return false.

class Solution {
    fun canFinish(numCourses: Int, prerequisites: Array<IntArray>): Boolean {
        
        val courseDict = mutableMapOf<Int, MutableList<Int>>()
//  to store course and list of next courses        

        for(courses in prerequisites){
            if(courseDict.containsKey(courses[1])){
                courseDict.get(courses[1])?.add(courses[0])
            }else{
                val nextCourses = mutableListOf<Int>()
                nextCourses.add(courses[0])
                courseDict.put(courses[1], nextCourses)
            }
        }

        val checkedArray = BooleanArray(numCourses)
//  maintain whether we can do courses for each course 

        val pathArray = BooleanArray(numCourses)

        for(currCourse in 0 until numCourses){
//  browse through all courses and see if there is a cycle meaning the course can't be done            
            if(isCyclic(currCourse, courseDict, checkedArray, pathArray)){
                return false
            }
        }

        return true
    }

    fun isCyclic(currCourse: Int, courseDict: MutableMap<Int, MutableList<Int>>, 
                    checkedArray: BooleanArray, pathArray: BooleanArray): Boolean{
        if(checkedArray[currCourse]){
//  all courses can be done for this course; no cycle would be formed
            return false
        }

        if(pathArray[currCourse]){
//  found a prev visited node -> cycle
            return true
        }

        if(!courseDict.containsKey(currCourse)){
//  no loop as no following courses          
            return false
        }

        pathArray[currCourse] = true
//  mark this one as visited

        var isCyclic = false
        if(courseDict.get(currCourse) != null){
            val coursesList = courseDict.get(currCourse) as List<Int>
            for(course in coursesList){
//  visit all the kids                
                isCyclic = isCyclic(course, courseDict, checkedArray, pathArray)
                if(isCyclic){
                    return true
                }
            }
        }

        pathArray[currCourse] = false
//  undo for next course

        checkedArray[currCourse] = true
//  we have visited all the kids and there is no cycle        

        return isCyclic
    }
}



Most Stones Removed with Same Row or Column - On a 2D plane, we place n stones at some integer coordinate points. Each coordinate point may have at most one stone.
A stone can be removed if it shares either the same row or the same column as another stone that has not been removed.
Given an array stones of length n where stones[i] = [xi, yi] represents the location of the ith stone, return the largest possible number of stones that can be removed.

class Solution {
    fun removeStones(stones: Array<IntArray>): Int {
        val visitedSet = mutableSetOf<Pair<Int, Int>>()

        var uniqueStoneGroups = 0

        for(stone in stones){
//  we need to go through all the stones
            val stoneCoords = Pair(stone[0], stone[1])
            if(stoneCoords !in visitedSet){
                uniqueStoneGroups++
//  we tried to find all the stones for the same group
                dfsSearch(stones, stoneCoords, visitedSet)
            }
        }

//  uniqueStoneGroups are the stones which have been removed except one cause it can't be removed as per condition
        return stones.size - uniqueStoneGroups
    }

    fun dfsSearch(stones: Array<IntArray>, stoneCoords: Pair<Int, Int>, 
                    visitedSet: MutableSet<Pair<Int, Int>>){
        visitedSet.add(stoneCoords)

        for(stone in stones){
            if(stone[0] == stoneCoords.first || stone[1] == stoneCoords.second){
                val nextStoneCoords = Pair(stone[0], stone[1])
                if(nextStoneCoords !in visitedSet){
                    dfsSearch(stones, nextStoneCoords, visitedSet)
                }
            }
        }
    }
}



Find Closest Node to Given Two Nodes - You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.

The graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.

You are also given two integers node1 and node2.

Return the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.

Note that edges may contain cycles.

class Solution {

    fun closestMeetingNode(edges: IntArray, node1: Int, node2: Int): Int {
        val numEdges = edges.size

//  store shortest distances of all the reachable nodes from both given nodes
        val distOneArray = IntArray(numEdges){Int.MAX_VALUE}
        distOneArray[node1] = 0
        val distTwoArray = IntArray(numEdges){Int.MAX_VALUE}
        distTwoArray[node2] = 0

//  fill the distances of all nodes from given two nodes
        fillDistances(node1, edges, distOneArray, BooleanArray(numEdges){false})
        fillDistances(node2, edges, distTwoArray, BooleanArray(numEdges){false})

        var minDistNode = -1
        var minDistanceTillNow = Int.MAX_VALUE
        for(currNode in 0 until numEdges){
            if(minDistanceTillNow > maxOf(distOneArray[currNode], distTwoArray[currNode])){
//  record the node which is closer to both                
                minDistNode = currNode
                minDistanceTillNow = maxOf(distOneArray[currNode], distTwoArray[currNode])
            }
        }

        return minDistNode
    }

    fun fillDistances(currNode: Int, edges: IntArray, distArray: IntArray, 
                        visitArray: BooleanArray){
        visitArray[currNode] = true
        val neighbor = edges[currNode]
        if(neighbor != -1 && !visitArray[neighbor]){
//  see if the neighbor is not visited
            distArray[neighbor] = 1 + distArray[currNode]
            fillDistances(neighbor, edges, distArray, visitArray)
        }
    }
}



All Nodes Distance K in Binary Tree - Given the root of a binary tree, the value of a target node target, and an integer k, return an array of the values of all nodes that have a distance k from the target node.

/**
 * Definition for a binary tree node.
 * class TreeNode(var `val`: Int = 0) {
 *     var left: TreeNode? = null
 *     var right: TreeNode? = null
 * }
 */
class Solution {
    val parentMap = mutableMapOf<TreeNode, TreeNode?>()

    fun distanceK(root: TreeNode?, target: TreeNode?, k: Int): List<Int> {
        fillParentMap(root, null)
//  now we have the parent for all the nodes

        val bfsQueue = LinkedList<TreeNode?>()
        bfsQueue.offer(null)
        bfsQueue.offer(target)

        val seenNodesSet = mutableSetOf<TreeNode?>()
        seenNodesSet.add(null)
        seenNodesSet.add(target)

        var distance = 0

        while(!bfsQueue.isEmpty()){
            val node = bfsQueue.poll()
            if(node == null){
                if(distance == k){
//  all the items left are from the same level                    
                    val result = mutableListOf<Int>()
                    for(node in bfsQueue){
                        if(node != null){
                            result.add(node.`val`)
                        }
                    }

                    return result.toList()
                }
                bfsQueue.offer(null)
                distance++
            }else{
                if(!seenNodesSet.contains(node.left)){
                    seenNodesSet.add(node.left)
                    bfsQueue.offer(node.left)
                }
                if(!seenNodesSet.contains(node.right)){
                    seenNodesSet.add(node.right)
                    bfsQueue.offer(node.right)
                }

                val parent = parentMap.get(node)
                if(!seenNodesSet.contains(parent)){
                    seenNodesSet.add(parent)
                    bfsQueue.offer(parent)
                }
            }
        }
        return listOf<Int>()
    }

    fun fillParentMap(node: TreeNode?, parent: TreeNode?){
        if(node != null){
            parentMap.put(node, parent)
            fillParentMap(node.left, node)
            fillParentMap(node.right, node)
        }
    }
}



Inorder traversal - Given the root of a binary tree, return the inorder traversal of its nodes' values.

const inorderTraversal = (root) => {
    const inorderList = []

    const findRecur = (node, inorderList) => {
        if (node) {
            findRecur(node.left, inorderList)
            inorderList.push(node.val)
            findRecur(node.right, inorderList)
        }
    }

    findRecur(root, inorderList)

    return inorderList
};




Sum of nodes with even valued grandparent - Given the root of a binary tree, return the sum of values of nodes with an even-valued grandparent. If there are no nodes with an even-valued grandparent, return 0.

const sumEvenGrandparent = (root) => {

    //  visit each node and maintain the parent and gparent

    let sum = 0

    const dfs = (node, parent, gparent) => {
        if (node) {
            if (gparent && gparent.val % 2 === 0) {
                sum += node.val
            }
            dfs(node.left, node, parent)
            dfs(node.right, node, parent)
        }
    }
    dfs(root, null, null)

    return sum

};



Battleships in a board - Given an m x n matrix board where each cell is a battleship 'X' or empty '.', return the number of the battleships on board.

Battleships can only be placed horizontally or vertically on board. In other words, they can only be made of the shape 1 x k (1 row, k columns) or k x 1 (k rows, 1 column), where k can be of any size. At least one horizontal or vertical cell separates between two battleships (i.e., there are no adjacent battleships).

/**
 * @param {character[][]} board
 * @return {number}
 */
const countBattleships = (board) => {

    //  solve using DFS

    let ships = 0

    const clearAdjacent = (board, row, col) => {
        if (row < 0 || row >= board.length || col < 0 || col >= board[row].length
            || board[row][col] === '.') {
            return
        }

        board[row][col] = '.'

        clearAdjacent(board, row + 1, col)
        clearAdjacent(board, row - 1, col)
        clearAdjacent(board, row, col + 1)
        clearAdjacent(board, row, col - 1)
    }

    //  visit each cell and mark adjacent cells
    for (let row = 0; row < board.length; row++) {
        for (let col = 0; col < board[row].length; col++) {
            if (board[row][col] === 'X') {
                //  found a ship as per def
                ships++
                clearAdjacent(board, row, col)
            }
        }
    }

    return ships
};


Find eventual safe states - There is a directed graph of n nodes with each node labeled from 0 to n - 1. The graph is represented by a 0-indexed 2D integer array graph where graph[i] is an integer array of nodes adjacent to node i, meaning there is an edge from node i to each node in graph[i].

A node is a terminal node if there are no outgoing edges. A node is a safe node if every possible path starting from that node leads to a terminal node (or another safe node).

Return an array containing all the safe nodes of the graph. The answer should be sorted in ascending order.

/**
 * @param {number[][]} graph
 * @return {number[]}
 */
const eventualSafeNodes = (graph) => {
    const ans = [];
    const map = new Map();
    for (let i = 0; i < graph.length; i++) {
        if (dfs(graph, i, map)) {
            ans.push(i);
        }
    }
    return ans;
};

const dfs = (graph, node, map) => {
    if (map.has(node)) {
        return map.get(node);
    }
    map.set(node, false);
    for (let nei of graph[node]) {
        if (!dfs(graph, nei, map)) {
            return false;
        }
    }
    map.set(node, true);
    return true;
}



Max area of island - You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.

The area of an island is the number of cells with a value 1 in the island.

Return the maximum area of an island in grid. If there is no island, return 0.

/**
 * @param {number[][]} grid
 * @return {number}
 */
const maxAreaOfIsland = (grid) => {
    const ROWS = grid.length
    const COLUMNS = grid[0].length

    const DFS = (row, column) => {
        //  we will store indices in this stack
        const stack = [[row, column]];
        let currRow, currColumn, resultArea = 0;
        while (stack.length !== 0) {
            [currRow, currColumn] = stack.pop();
            if (grid[currRow][currColumn] !== 1)
                continue;

            //  stop duplication
            grid[currRow][currColumn] = 2;

            //  found further land
            resultArea++;

            //  explore 4 directions
            if (currRow + 1 < ROWS)
                stack.push([currRow + 1, currColumn]);
            if (currRow - 1 >= 0)
                stack.push([currRow - 1, currColumn]);
            if (currColumn + 1 < COLUMNS)
                stack.push([currRow, currColumn + 1]);
            if (currColumn - 1 >= 0)
                stack.push([currRow, currColumn - 1]);
        }
        return resultArea;
    };

    let maxArea = 0

    //  visit each cell
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLUMNS; c++) {
            if (grid[r][c] === 1) {
                maxArea = Math.max(maxArea, DFS(r, c))
            }
        }
    }
    return maxArea
};

