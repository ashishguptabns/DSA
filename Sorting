/* Sort the matrix diagonally - Given an m x n matrix mat of integers, sort each matrix diagonal in ascending order and return the resulting matrix.
 */
const diagonalSort = (mat) => {
    const numRows = mat.length
    const numCols = mat[0].length

    for (let col = 0; col < numCols; col++) {
        //  sort the upper half
        sort(mat, 0, col)
    }

    for (let row = 1; row < numRows; row++) {
        //  sort the lower half
        sort(mat, row, 0)
    }

    return mat

};

const sort = (mat, row, col) => {
    const diagonal = []

    while (row < mat.length && col < mat[0].length) {
        diagonal.push(mat[row++][col++])
    }

    diagonal.sort((a, b) => a - b)

    while (row > 0 && col > 0) {
        //  put the elements back
        mat[--row][--col] = diagonal.pop()
    }
}

/* Wiggle sort - Given an integer array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]....
 */
const wiggleSort = (nums) => {
    const copy = [...nums]
    copy.sort((a, b) => a - b)

    let index = copy.length - 1

    for (let i = 1; i < nums.length; i += 2) {
        //  put big numbers at odd positions
        nums[i] = copy[index]
        index--
    }

    for (let i = 0; i < nums.length; i += 2) {
        //  put remaining in even positions
        nums[i] = copy[index]
        index--
    }
};

/* Maximum ice cream bars - At the store, there are n ice cream bars. You are given an array costs of length n, where costs[i] is the price of the ith ice cream bar in coins. The boy initially has coins coins to spend, and he wants to buy as many ice cream bars as possible. 

Note: The boy can buy the ice cream bars in any order.

Return the maximum number of ice cream bars the boy can buy with coins coins.

You must solve the problem by counting sort.
 */
/**
 * @param {number[]} costs
 * @param {number} coins
 * @return {number}
 */
/**
 * @param {number[]} costs
 * @param {number} coins
 * @return {number}
 */
const maxIceCream = (costs, coins) => {

    //  track frequencies of each cost entity
    const frequencies = Array(Math.max(...costs) + 1).fill(0)
    for (const cost of costs) {
        frequencies[cost] += 1
    }

    let bars = 0
    //  we are moving from low to high so count will be maximum
    for (let cost = 1; cost <= coins && cost < frequencies.length; ++cost) {
        //  min is required cause there might not be enough coins or enough items
        const count = Math.min(frequencies[cost], Math.floor(coins / cost))

        //  update left coins
        coins -= cost * count
        bars += count
    }
    return bars
};