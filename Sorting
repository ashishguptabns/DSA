/* Sort the matrix diagonally - Given an m x n matrix mat of integers, sort each matrix diagonal in ascending order and return the resulting matrix.
 */
const diagonalSort = (mat) => {
    const numRows = mat.length
    const numCols = mat[0].length

    const sort = (mat, row, col) => {
        const diagonal = []
    
        while (row < mat.length && col < mat[0].length) {
            diagonal.push(mat[row++][col++])
        }
    
        diagonal.sort((a, b) => a - b)
    
        while (row > 0 && col > 0) {
            //  put the elements back
            mat[--row][--col] = diagonal.pop()
        }
    }

    for (let col = 0; col < numCols; col++) {
        //  sort the upper half
        sort(mat, 0, col)
    }

    for (let row = 1; row < numRows; row++) {
        //  sort the lower half
        sort(mat, row, 0)
    }

    return mat

};



/* Wiggle sort - Given an integer array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]....
 */
const wiggleSort = (nums) => {
    const copy = [...nums]
    copy.sort((a, b) => a - b)

    let index = copy.length - 1

    for (let i = 1; i < nums.length; i += 2) {
        //  put big numbers at odd positions
        nums[i] = copy[index]
        index--
    }

    for (let i = 0; i < nums.length; i += 2) {
        //  put remaining in even positions
        nums[i] = copy[index]
        index--
    }
};

/* Maximum ice cream bars - At the store, there are n ice cream bars. You are given an array costs of length n, where costs[i] is the price of the ith ice cream bar in coins. The boy initially has coins coins to spend, and he wants to buy as many ice cream bars as possible. 

Note: The boy can buy the ice cream bars in any order.

Return the maximum number of ice cream bars the boy can buy with coins coins.

You must solve the problem by counting sort.
 */
/**
 * @param {number[]} costs
 * @param {number} coins
 * @return {number}
 */
/**
 * @param {number[]} costs
 * @param {number} coins
 * @return {number}
 */
const maxIceCream = (costs, coins) => {

    //  track frequencies of each cost entity
    const frequencies = Array(Math.max(...costs) + 1).fill(0)
    for (const cost of costs) {
        frequencies[cost] += 1
    }

    let bars = 0
    //  we are moving from low to high so count will be maximum
    for (let cost = 1; cost <= coins && cost < frequencies.length; ++cost) {
        //  min is required cause there might not be enough coins or enough items
        const count = Math.min(frequencies[cost], Math.floor(coins / cost))

        //  update left coins
        coins -= cost * count
        bars += count
    }
    return bars
};

/* Group anagrams - Given an array of strings strs, group the anagrams together. You can return the answer in any order. */

/**
 * @param {string[]} strs
 * @return {string[][]}
 */
const groupAnagrams = (strs) => {
    //  sort the strings and maintain a map

    const map = new Map()

    const getHash = (str) => {
        return str.split('').sort().join('')
    }
    strs.forEach((str) => {
        const key = getHash(str)
        if (map.has(key)) {
            map.get(key).push(str)
        } else {
            map.set(key, [str])
        }
    })

    return [...map.values()]
};

/* 
H-index - Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return the researcher's h-index.

According to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.
 */

/**
 * @param {number[]} citations
 * @return {number}
 */
const hIndex = (citations) => {
    citations.sort((a, b) => a - b)
    let res = 0
    let n = citations.length

    for (let i = 0; i < n; i++) {
        //  assume ith index has 6 citations but only 3 more papers have higher citation than 6
        res = Math.max(res, Math.min(citations[i], n - i))
    }

    return res
};