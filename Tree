/* Lowest Common Ancestor of two nodes in a Binary Tree - Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.

According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” */

const lowestCommonAncestor = (root, p, q) => {
    if (!root || root === p || root === q) {
        return root;
    }

    //  check if any node is present in left or right subtree
    const left = lowestCommonAncestor(root.left, p, q);
    const right = lowestCommonAncestor(root.right, p, q);

    if (left && right) {
        //  we found one node each in left and right subtree hence this is the LCA
        return root;
    } else {
        return left || right;
    }
}

/* Minimum Time to Collect All Apples in a Tree - Given an undirected tree consisting of n vertices numbered from 0 to n-1, which has some apples in their vertices. You spend 1 second to walk over one edge of the tree. Return the minimum time in seconds you have to spend to collect all apples in the tree, starting at vertex 0 and coming back to this vertex.

The edges of the undirected tree are given in the array edges, where edges[i] = [ai, bi] means that exists an edge connecting the vertices ai and bi. Additionally, there is a boolean array hasApple, where hasApple[i] = true means that vertex i has an apple; otherwise, it does not have any apple.
 */
/**
 * @param {number} n
 * @param {number[][]} edges
 * @param {boolean[]} hasApple
 * @return {number}
 */
const minTime = (n, edges, hasApple) => {
    const adjlist = Array.from({ length: n }, () => new Array());
    for (const [from, to] of edges) {
        //  undirected edges
        adjlist[from].push(to);
        adjlist[to].push(from);
    }

    const dfs = (node, parent) => {
        let pathlen = 0;
        for (const neighbour of adjlist[node]) {
            if (neighbour == parent) {
                //  skip the parent cause counting is already done
                continue;
            }
            pathlen += dfs(neighbour, node);
        }
        if (node == 0) {
            return pathlen;
        }
        return pathlen > 0 || hasApple[node] ? pathlen + 2 : 0;
    }

    //  start with root
    return dfs(0, -1);
};

/* Add One Row to Tree - Given the root of a binary tree and two integers val and depth, add a row of nodes with value val at the given depth depth.
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} val
 * @param {number} depth
 * @return {TreeNode}
 */
const addOneRow = (root, val, depth) => {
    if (!root) {
        return root
    }

    if (depth === 1) {
        return new TreeNode(val, root)
    }

    const refactor = (node, currDepth) => {
        if (!node) {
            return
        }

        if (currDepth === depth - 1) {
            const { left, right } = node
            node.left = new TreeNode(val, left)
            node.right = new TreeNode(val, null, right)
        }

        refactor(node.left, currDepth + 1)
        refactor(node.right, currDepth + 1)
    }
    refactor(root, 1)

    return root
};

/* Binary Tree Maximum Path Sum - A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them.A node can only appear in the sequence at most once.Note that the path does not need to pass through the root.

The path sum of a path is the sum of the node's values in the path.

Given the root of a binary tree, return the maximum path sum of any non - empty path.
 */
/**
 * Example:
 * var ti = TreeNode(5)
 * var v = ti.`val`
 * Definition for a binary tree node.
 * class TreeNode(var `val`: Int) {
 *     var left: TreeNode? = null
 *     var right: TreeNode? = null
 * }
 */
class Solution {
    var maxSum = Int.MIN_VALUE
    fun maxPathSum(root: TreeNode ?): Int {

    countGainFromSubTree(root)
    return maxSum
}

    fun countGainFromSubTree(node: TreeNode ?): Int{
    if (node == null) {
        return 0
    }

//  post order traversal
//  sum can be negative then ignore
        val leftMax = maxOf(countGainFromSubTree(node.left), 0)
        val rightMax = maxOf(countGainFromSubTree(node.right), 0)

    //  find max till this subtree; taking both the subtrees
    maxSum = maxOf(maxSum, leftMax + rightMax + node.`val`)

    //  we have to take a path hence right or left subtree not both
    return node.`val` + maxOf(leftMax, rightMax)
}
}



Implement Trie(Prefix Tree)

class TrieNode {
    value: string
    kids: Map<string, TrieNode>
    isEndOfWord: boolean

    constructor(value: string) {
        this.value = value
        this.kids = new Map()
        this.isEndOfWord = false
    }
}

class Trie {

    root: TrieNode

    constructor() {
        //  no alphabet to avoid confusion        
        this.root = new TrieNode("_")
    }

    insert(word: string): void {
        let currNode = this.root
        for (let i = 0; i < word.length; i++) {
            const char = word[i]
            if (!currNode.kids.has(char)) {
                currNode.kids.set(char, new TrieNode(char))
            }
            currNode = currNode.kids.get(char)
        }
        currNode.isEndOfWord = true
    }

    search(word: string): boolean {
        let currNode = this.root
        for (let i = 0; i < word.length; i++) {
            const char = word[i]
            if (!currNode.kids.has(char)) {
                return false
            }
            currNode = currNode.kids.get(char)
        }

        return currNode.isEndOfWord
    }

    startsWith(prefix: string): boolean {
        let currNode = this.root
        for (let i = 0; i < prefix.length; i++) {
            const char = prefix[i]
            if (!currNode.kids.has(char)) {
                return false
            }
            currNode = currNode.kids.get(char)
        }
        return true
    }

}

/**
 * Your Trie object will be instantiated and called as such:
 * var obj = new Trie()
 * obj.insert(word)
 * var param_2 = obj.search(word)
 * var param_3 = obj.startsWith(prefix)
 */



Kth Smallest Element in a BST

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} k
 * @return {number}
 */
const kthSmallest = function (root, k) {
    const inorderArr = []

    const inorder = (root) => {
        if (root) {
            inorder(root.left)
            inorderArr.push(root.val)
            inorder(root.right)
        }
    }

    inorder(root)

    //  k = 1 means 0th element
    return inorderArr[k - 1]
};


Binary Tree Level Order Traversal

/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
const levelOrder = (root) => {

    const res = []

    if (root) {
        const queue = [root]

        while (queue.length) {
            const levelSize = queue.length
            const currLevelNodes = []
            for (let i = 0; i < levelSize; i++) {
                const currNode = queue.shift()
                if (currNode.left) {
                    queue.push(currNode.left)
                }
                if (currNode.right) {
                    queue.push(currNode.right)
                }
                currLevelNodes.push(currNode.val)
            }
            res.push([...currLevelNodes])
        }
    }
    return res
};


Construct Binary Tree from Preorder and Inorder Traversal - Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
const buildTree = (preorder, inorder) => {
    if (preorder.length) {
        const currRoot = new TreeNode(preorder[0])

        const currRootIndexInInorder = inorder.indexOf(currRoot.val)

        //  preorder is root, left, right
        const preOrderForLeftTree = preorder.slice(1, currRootIndexInInorder + 1)
        //  inorder is left, root, right
        const inOrderForLeftTree = inorder.slice(0, currRootIndexInInorder)

        currRoot.left = buildTree(preOrderForLeftTree, inOrderForLeftTree)

        const preOrderForRightTree = preorder.slice(currRootIndexInInorder + 1)
        const inOrderForRightTree = inorder.slice(currRootIndexInInorder + 1)

        currRoot.right = buildTree(preOrderForRightTree, inOrderForRightTree)

        return currRoot
    }
    return null
};

/* Inorder Successor in BST - Given the root of a binary search tree and a node p in it, return the in -order successor of that node in the BST.If the given node has no in -order successor in the tree, return null.

The successor of a node p is the node with the smallest key greater than p.val.
 */
/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

const inorderSuccessor = (root, p) => {
    let currNode = root
    let successor

    while (currNode != null) {
        if (currNode.val > p.val) {
            successor = currNode
            //  we have to go towards left to find the successor
            currNode = currNode.left
        } else {
            //  go towards the right
            currNode = currNode.right
        }
    }

    return successor
};



Populating Next Right Pointers in Each Node - You are given a perfect binary tree where all leaves are on the same level, and every parent has two children.Populate each next pointer to point to its next right node.If there is no next right node, the next pointer should be set to NULL.

/**
 * Definition for Node.
 * class Node {
 *     val: number
 *     left: Node | null
 *     right: Node | null
 *     next: Node | null
 *     constructor(val?: number, left?: Node, right?: Node, next?: Node) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */

function connect(root: Node | null): Node | null {
    if (!root) {
        return null
    }

    //  we will try to go towards the left most node and connect all the nodes in the next level
    let leftMostNode: Node = root
    while (leftMostNode.left !== null) {
        let currNode = leftMostNode
        while (currNode != null) {
            //  make the connect of direct kids            
            currNode.left.next = currNode.right

            //  make the connect with neighbors' kids            
            if (currNode.next != null) {
                currNode.right.next = currNode.next.left
            }

            //  move to right side and repeat            
            currNode = currNode.next
        }

        //  move to new level
        leftMostNode = leftMostNode.left
    }

    return root
};



Check Completeness of a Binary Tree - Given the root of a binary tree, determine if it is a complete binary tree.

In a complete binary tree, every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible.It can have between 1 and 2h nodes inclusive at the last level h.

/**
 * Definition for a binary tree node.
 * class TreeNode {
 *     val: number
 *     left: TreeNode | null
 *     right: TreeNode | null
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.left = (left===undefined ? null : left)
 *         this.right = (right===undefined ? null : right)
 *     }
 * }
 */

function isCompleteTree(root: TreeNode | null): boolean {

    if (!root) {
        return true
    }

    const bfsQueue: (TreeNode | null)[] = [root]
    let foundNull = false

    while (bfsQueue.length > 0) {
        const currNode = bfsQueue.shift()

        if (currNode == null) {
            foundNull = true
        } else {
            if (foundNull) {
                //  found a non-null node after a null node; not allowed
                return false
            }

            bfsQueue.push(currNode.left)
            bfsQueue.push(currNode.right)
        }
    }

    return true
};

/* Find Duplicate Subtrees - Given the root of a binary tree, return all duplicate subtrees.
For each kind of duplicate subtrees, you only need to return the root node of any one of them.
Two trees are duplicate if they have the same structure with the same node values.
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode[]}
 */
const findDuplicateSubtrees = (root) => {
    const map = new Map()
    const result = []

    const dfs = (currNode, result, map) => {
        if (!currNode) {
            //  used to represent null node
            return '#'
        }

        //  store pre order in a string
        const subtree = `${currNode.val},${dfs(currNode.left, result, map)},${dfs(currNode.right, result, map)}`
        const freq = map.get(subtree) || 0

        if (freq == 1) {
            //  found a duplicate        
            result.push(currNode)
        }

        //  maintain the freq
        map.set(subtree, freq + 1)

        //  return the string signature
        return subtree
    }
    dfs(root, result, map)

    return result
};

/* Count nodes equal to average of subtress - Given the root of a binary tree, return the number of nodes where the value of the node is equal to the average of the values in its subtree. 
Subtree includes the root
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
const averageOfSubtree = (root) => {
    const countAvgNodes = { count: 0 }

    dfs(root, countAvgNodes)

    return countAvgNodes.count
};

const dfs = (node, countAvgNodes) => {
    if (node) {
        const leftCountSum = dfs(node.left, countAvgNodes)
        const rightCountSum = dfs(node.right, countAvgNodes)

        const subTreeSum = leftCountSum.sum + rightCountSum.sum + node.val
        const subTreeCount = 1 + leftCountSum.count + rightCountSum.count

        const avg = Math.floor(subTreeSum / subTreeCount)

        if (avg === node.val) {
            countAvgNodes.count++
        }

        //  send the count also to track
        return { count: subTreeCount, sum: subTreeSum }
    }

    return { count: 0, sum: 0 }
}



Maximum binary tree - You are given an integer array nums with no duplicates.A maximum binary tree can be built recursively from nums using the following algorithm:
Create a root node whose value is the maximum value in nums.
Recursively build the left subtree on the subarray prefix to the left of the maximum value.
Recursively build the right subtree on the subarray suffix to the right of the maximum value.
Return the maximum binary tree built from nums.

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} nums
 * @return {TreeNode}
 */
const constructMaximumBinaryTree = (nums) => {
    if (nums.length === 0) {
        return null;
    }

    // Find the index of the maximum value in the array
    const maxIndex = getMaxIndex(nums);

    // Create a root node with the maximum value
    const root = new TreeNode(nums[maxIndex]);

    // Recursively build the left subtree
    root.left = constructMaximumBinaryTree(nums.slice(0, maxIndex));

    // Recursively build the right subtree
    root.right = constructMaximumBinaryTree(nums.slice(maxIndex + 1));

    return root;
};

const getMaxIndex = (nums) => {
    let maxIndex = 0;
    for (let i = 1; i < nums.length; i++) {
        if (nums[i] > nums[maxIndex]) {
            maxIndex = i;
        }
    }
    return maxIndex;
}



BST from preorder - Given an array of integers preorder, which represents the preorder traversal of a BST(i.e., binary search tree), construct the tree and return its root.

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} preorder
 * @return {TreeNode}
 */
const bstFromPreorder = (preorder) => {
    let i = 0
    const process = (bound) => {
        if (i === preorder.length || preorder[i] > bound) {
            return null
        }

        const num = preorder[i]
        const node = new TreeNode(num)
        i++

        //  curr node is the bound for left subtree
        node.left = process(node.val)
        //  ancestor bound is the bound for right subtree
        node.right = process(bound)

        return node
    }

    return process(Number.MAX_SAFE_INTEGER)
};



Convert a BST into a GST(greater sum tree) - Given the root of a Binary Search Tree(BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
const bstToGst = (root) => {
    //  we will do reverse inorder traversal and maintain the sum while coming from right

    let sum = 0

    const reverseInorder = (node) => {
        if (node) {
            reverseInorder(node.right)

            sum += node.val
            node.val = sum

            reverseInorder(node.left)
        }
    }
    reverseInorder(root)

    return root
};


Balance a BST - Given the root of a binary search tree, return a balanced binary search tree with the same node values.If there is more than one answer, return any of them.

A binary search tree is balanced if the depth of the two subtrees of every node never differs by more than 1.

const balanceBST = (root) => {
    const toArray = (node) => {
        if (node) {
            return [...toArray(node.left), node.val, ...toArray(node.right)]
        } else {
            return []
        }
    }

    //  get node values in inorder
    const nodesInOrder = toArray(root)

    const toBST = (nodesInOrder) => {
        if (nodesInOrder.length === 0) {
            return null
        }
        if (nodesInOrder.length === 1) {
            return new TreeNode(nodesInOrder[0])
        }

        // divide the array by half
        const mid = Math.floor(nodesInOrder.length / 2)

        const leftSub = toBST(nodesInOrder.slice(0, mid))
        const rightSub = toBST(nodesInOrder.slice(mid + 1))

        return new TreeNode(nodesInOrder[mid], leftSub, rightSub)
    }

    return toBST(nodesInOrder)
};


Reverse odd levels of binary tree - Given the root of a perfect binary tree, reverse the node values at each odd level of the tree.

const reverseOddLevels = (root) => {
    //  do a BFS travel
    let queue = [root]
    let level = 0
    while (queue.length) {
        //  record next level to preserve order
        const nextLevel = []
        for (let i = 0; i < queue.length; i++) {
            const node = queue[i]
            if (node.left) {
                nextLevel.push(node.left)
            }
            if (node.right) {
                nextLevel.push(node.right)
            }
        }

        if (level % 2) {
            //  odd level; revers the current queue
            for (let i = 0, j = queue.length - 1; i < j; i++, j--) {
                const temp = queue[i].val
                queue[i].val = queue[j].val
                queue[j].val = temp
            }
        }

        //  move to next level
        queue = nextLevel
        level++
    }

    return root
};

/* Path In Zigzag Labelled Binary Tree - In an infinite binary tree where every node has two children, the nodes are labelled in row order.

In the odd numbered rows(ie., the first, third, fifth, ...), the labelling is left to right, while in the even numbered rows(second, fourth, sixth, ...), the labelling is right to left.

Given the label of a node in this tree, return the labels in the path from the root of the tree to the node with that label.
 */
/**
 * @param {number} label
 * @return {number[]}
 */
const pathInZigZagTree = (label) => {
    let level = 0;

    //  find the level of label
    while (Math.pow(2, level + 1) <= label) {
        level++;
    }

    const getParent = (label, lvl) => {
        if (label === 1) {
            //  no parent of root
            return [];
        }
        const lvlMaxVal = Math.pow(2, lvl + 1) - 1, lvlMinVal = Math.pow(2, lvl);
        const mirror = lvlMinVal + (lvlMaxVal - label);

        //  parent by def
        const parent = Math.floor(mirror / 2);

        //  find parent to this parent and so on
        return [...getParent(parent, lvl - 1), parent];
    }
    return [...getParent(label, level), label];
};

Construct quad tree - Given a n * n matrix grid of 0's and 1's only.We want to represent grid with a Quad - Tree.

Return the root of the Quad - Tree representing grid.

/**
 * // Definition for a QuadTree node.
 * function Node(val,isLeaf,topLeft,topRight,bottomLeft,bottomRight) {
 *    this.val = val;
 *    this.isLeaf = isLeaf;
 *    this.topLeft = topLeft;
 *    this.topRight = topRight;
 *    this.bottomLeft = bottomLeft;
 *    this.bottomRight = bottomRight;
 * };
 */

/**
 * @param {number[][]} grid
 * @return {Node}
 */
const construct = (grid) => {
    //  n * n grid
    let n = grid.length;

    //  rowStart, rowEnd, colStart, colEnd
    const quadTree = (rs, re, cs, ce) => {
        const len = re - rs;
        if (len === 1) {
            //  leaf node
            return new Node(grid[rs][cs], 1);
        }
        let mid = Math.floor(len / 2);

        //  find children
        let topLeft = quadTree(rs, rs + mid, cs, cs + mid);
        let topRight = quadTree(rs, rs + mid, cs + mid, ce);
        let bottomLeft = quadTree(rs + mid, re, cs, cs + mid);
        let bottomRight = quadTree(rs + mid, re, cs + mid, ce);

        const topLeftVal = topLeft.val
        //  all children are leafs
        if (topLeft.isLeaf && topRight.isLeaf && bottomLeft.isLeaf && bottomRight.isLeaf) {
            //  all children have same values
            if (topLeftVal === topRight.val && topLeftVal === bottomLeft.val && topLeftVal === bottomRight.val) {
                //  leaf node
                return new Node(topLeftVal, 1);
            }
        }

        //  not a leaf node
        return new Node(1, 0, topLeft, topRight, bottomLeft, bottomRight);
    }
    const head = quadTree(0, n, 0, n);
    return head;
};

BST to sorted DLL

const bstToDoublyLinkedList = (root) => {
    if (root === null) {
        return null;
    }

    const convertBSTtoDLL = (root, prevNode) => {
        if (root === null) {
            return prevNode;
        }

        // Recursively convert the left subtree
        prevNode = convertBSTtoDLL(root.left, prevNode);

        // Convert current node
        const currentNode = new DoublyLinkedListNode(root.val);
        currentNode.prev = prevNode;
        if (prevNode) {
            prevNode.next = currentNode;
        }

        // Recursively convert the right subtree
        return convertBSTtoDLL(root.right, currentNode);
    };

    // Start the in-order traversal
    const head = convertBSTtoDLL(root, null);

    // Find the head of the doubly linked list
    while (head.prev !== null) {
        head = head.prev;
    }

    return head;
};

/* Binary tree right side view - Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.
 */
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
const rightSideView = (root, ans = [], depth = 0) => {
    if (!root) {
        return ans
    }
    ans[depth] = root.val

    //  keep putting values from left to right for a depth
    rightSideView(root.left, ans, depth + 1)
    //  right side values will always override the left ones
    return rightSideView(root.right, ans, depth + 1)
};

/* Binary tree zigzag level order traversal - Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).
*/

/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
const zigzagLevelOrder = (root) => {
    let res = []

    if (root) {
        const queue = [[root, 0]]
        while (queue.length) {
            const [node, level] = queue.shift()

            //  init if null
            res[level] ??= []

            if (level % 2 == 1) {
                //  travelling from left to right
                res[level].push(node.val)
            } else {
                //  travelling from right to left
                res[level].unshift(node.val)
            }
            if (node.right) {
                queue.push([node.right, level + 1])
            }
            if (node.left) {
                queue.push([node.left, level + 1])
            }
        }
    }

    return res
};