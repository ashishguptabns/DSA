/* Longest Palindromic substring - Given a string s, return the longest Palindromic substring in s. */

/**
 * @param {string} s
 * @return {string}
 */
const longestPalindrome = (s) => {
    const strLength = s.length
    if (strLength <= 1) {
        return s
    }

    const dpMatrix = Array.from({ length: strLength }, () => Array(strLength).fill(false))

    //  all substrings of length 1 are palindrome
    for (let i = 0; i < strLength - 1; i++) {
        dpMatrix[i][i] = true
    }

    // to track palindrome start index
    let startIndex = 0
    let maxLength = 1

    //  handle substrings of length 2
    for (let i = 0; i < strLength - 1; i++) {
        if (s[i] == s[i + 1]) {
            dpMatrix[i][i + 1] = true
            startIndex = i
            maxLength = 2
        }
    }

    //  handle substrings of length 3 or more
    for (let currLen = 3; currLen <= strLength; currLen++) {
        for (let i = 0; i <= strLength - currLen; i++) {
            //  end index for substring
            const j = i + currLen - 1

            //  check if the substring is a palindrome
            if (s[i] == s[j] && dpMatrix[i + 1][j - 1]) {
                dpMatrix[i][j] = true
                startIndex = i
                maxLength = currLen
            }
        }
    }

    return s.substring(startIndex, startIndex + maxLength)
};



Maximum Subarray - Given an integer array nums, find the subarray with the largest sum, and return its sum.

class Solution {
    fun maxSubArray(nums: IntArray): Int {
//         this problem can be solved using DP approach
        
        var currSubArray = nums[0]
        var maxSubArray = nums[0]
        
        for(i in 1..nums.size - 1){
            val num = nums[i]
            
//             check if the currSubArray is worth keeping. We can discard the previous subarray if its sum is less than the current index
            currSubArray = Math.max(num, currSubArray + num)
            
//             if current sub array has more sum than max
            maxSubArray = Math.max(currSubArray, maxSubArray)
        }
        
        return maxSubArray
    }
}

/* Flip String to Monotone Increasing - A binary string is monotone increasing if it consists of some number of 0's (possibly none), followed by some number of 1's (also possibly none).

You are given a binary string s. You can flip s[i] changing it from 0 to 1 or from 1 to 0.

Return the minimum number of flips to make s monotone increasing.
 */
/**
 * @param {string} s
 * @return {number}
 */
const minFlipsMonoIncr = (s) => {
    let numOfOnesSoFar = 0
    let numFlips = 0

    for (const c of s) {
        if (c === '1') {
            //  this is monotone increasing, no flips required             
            numOfOnesSoFar++
        } else {
            //  we might have to flip this character '0' or all the 1s we found so far                
            numFlips = Math.min(numOfOnesSoFar, numFlips + 1)
        }
    }

    return numFlips
};

/* House Robber - You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.
 */
class Solution {
    fun rob(nums: IntArray): Int {
//	0th index meas 0 houses hence no money
        var money = IntArray(nums.size + 1)

        if(nums.size == 0){
            return 0
        }else if(nums.size == 1){
            return nums[0]
        }

//	only one house to rob
        money[1] = nums[0]

//	start from the 2nd house 
        for(houseNum in 2 until nums.size + 1){

//	choose either the money robbed till the last house or current house with prev to prev houses as per definition
            money[houseNum] = Math.max(money[houseNum - 1], nums[houseNum - 1] + money[houseNum - 2])
        }

//	we are done robbing nums.size houses
        return money[nums.size];
    }
}




Maximum Length of Repeated Subarray - Given two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in both arrays.


class Solution {
    fun findLength(nums1: IntArray, nums2: IntArray): Int {

//	extra length to ensure we cover all the items in each array
        var dp = Array(nums1.size + 1) { IntArray(nums2.size + 1) }

        var maxLength = 0;

//      for each subarray ending at i in nums1 and j in nums2, max length of common sub array will be dp[i][j] + (1 if nums1[i] == nums2[j])

        for(i in 0 until nums1.size){
            for(j in 0 until nums2.size){
                if(nums1[i] == nums2[j]){
                    dp[i + 1][j + 1] = 1 + dp[i][j]
                }

                maxLength = Math.max(maxLength, dp[i + 1][j + 1])
            }
        }         
        return maxLength;
    }
}

/* Coin Change - You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.

Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.

You may assume that you have an infinite number of each kind of coin.
 */
class Solution {
    fun coinChange(coins: IntArray, amount: Int): Int {

//      each index ith value means num coins to make i amount        
        var numCoinsDPArr = IntArray(amount + 1){(amount + 1)}

//      0 coins to make 0 amount        
        numCoinsDPArr[0] = 0;

        for(i in 1 until amount + 1){
            for(j in 0 until coins.size){
//      we found a coin with less value than i means there is a chance to combine coins and make this value 'i'                
                if(coins[j] <= i){
//      if we choose coins[j] then we have 1 coin selected and now need num of coins to make 'i - coins[j]' value
                    numCoinsDPArr[i] = minOf(numCoinsDPArr[i], 1 + numCoinsDPArr[i - coins[j]])
                }
            }
        }

        if(numCoinsDPArr[amount] == amount + 1){
            return -1
        }else{
            return numCoinsDPArr[amount]
        }
    }
}


/* Perfect Squares - Given an integer n, return the least number of perfect square numbers that sum to n.
 */
class Solution {
    fun numSquares(n: Int): Int {

//  we will maintain a dp array where ith index tells the numbers of perfect squares needed to make i
//  for each i; i numbers 1s are needed at max

        var dp = IntArray(n + 1){i -> i}

        for(number in 1 until n + 1){
            val sqrt = Math.sqrt(number * 1.0).toInt()

            for(candidate in 1 until sqrt + 1){

                if(number < candidate * candidate){
                    break
                }

//  we choose the candidate as a member hence adding 1                 
                dp[number] = minOf(dp[number], 1 + dp[number - (candidate * candidate)])
            }
        }

        return dp[n]
    }
}

/* Palindrome Partitioning - Given a string s, partition s such that every 
substring of the partition is a palindrome. Return all possible palindrome partitioning of s.
 */
/**
 * @param {string} s
 * @return {string[][]}
 */
const partition = (s) => {
    //  use DP

    const dp = Array.from({ length: s.length }, () => Array(s.length).fill(false))

    const res = []

    const dfs = (start, currList) => {
        if (start == s.length) {
            //  reached the end
            res.push([...currList])
        }

        //  explore all substrings
        for (let end = start; end < s.length; end++) {
            //  found a palindrome
            if (s[start] === s[end] && (end - start <= 2 || dp[start + 1][end - 1])) {
                dp[start][end] = true
                currList.push(s.slice(start, end + 1))
                dfs(end + 1, currList)
                //  remove this palindrome for further iterations
                currList.pop()
            }
        }
    }

    dfs(0, [])

    return res
};

/* Longest Common Subsequence - Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.
 */
/**
 * @param {string} text1
 * @param {string} text2
 * @return {number}
 */
const longestCommonSubsequence = (text1, text2) => {
    // Don't have to be contiguous

    const dp = Array.from({ length: text1.length + 1 },
        () => Array(text2.length + 1).fill(0));

    //  start from the end of both strings
    for (let i = text1.length - 1; i >= 0; i--) {
        for (let j = text2.length - 1; j >= 0; j--) {
            if (text1[i] === text2[j]) {
                dp[i][j] = 1 + dp[i + 1][j + 1];
            } else {
                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j + 1]);
            }
        }
    }

    return dp[0][0];
};

/* Sum of Subarray Minimums - Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.
 */
class Solution {
    fun sumSubarrayMins(arr: IntArray): Int {
        val subArrayMinSumsDP = IntArray(arr.size)
//  this dp array will keep the sum of mins of subarrays ending at index i

        val indicesStack = mutableListOf<Int>()
        val MOD = 1_00_00_00_007

        for(counter in 0 until arr.size){
            while(!indicesStack.isEmpty() && arr[indicesStack.last()] >= arr[counter]){
//  monotonic stack
//  find the smaller item which will control the sums till its index
                indicesStack.removeAt(indicesStack.size - 1)
            }

            if(indicesStack.size > 0){
//  there is a prev smaller item                
                val prevSmallIndex = indicesStack.last()
//  we already have the sums till prev small item index and for the remaining the current item is the smallest
                subArrayMinSumsDP[counter] =  
                (counter - prevSmallIndex) * arr[counter] + subArrayMinSumsDP[prevSmallIndex] 
            }else{
//  for all the items before counter, current one is the smallest                
                subArrayMinSumsDP[counter] = (counter + 1) * arr[counter]
            }
            indicesStack.add(counter)
        }

        var sumOfMins = 0L
        for(sum in subArrayMinSumsDP){
            sumOfMins += sum
            sumOfMins %= MOD
        }

        return sumOfMins.toInt()
    }
}

/* Maximum Product Subarray - Given an integer array nums, find a subarray that has the largest product, and return the product
 */
class Solution {
    fun maxProduct(nums: IntArray): Int {
        if(nums.size == 0){
            return 0
        }

        var maxProductSoFar = nums[0]
        var minProductSoFar = nums[0]
        var result = maxProductSoFar

        for(counter in 1 until nums.size){
            val currNum = nums[counter]

//  either we discard the prev subarray or we choose
            val tempMax = maxOf(currNum, 
                            maxOf(currNum * maxProductSoFar, currNum * minProductSoFar))

//  because we have negative numbers; minProductSoFar can make big number later
            minProductSoFar = minOf(currNum, 
                            minOf(currNum * maxProductSoFar, currNum * minProductSoFar))

            maxProductSoFar = tempMax
            result = maxOf(result, maxProductSoFar)
        }

        return result
    }
}

/* 
Unique Paths - There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.

Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.
 */
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
const uniquePaths = (m, n) => {
    //  solve this using DP

    const dp = Array.from({ length: m }, () => new Array(n).fill(0))

    //  only one way to cover all rows in first column
    for (let row = 0; row < m; row++) {
        dp[row][0] = 1
    }
    //  only one way to cover all columns in first row
    for (let col = 0; col < n; col++) {
        dp[0][col] = 1
    }

    //  fill the remaining cells
    for (let row = 1; row < m; row++) {
        for (let col = 1; col < n; col++) {
            //  can come from top or left
            dp[row][col] = dp[row - 1][col] + dp[row][col - 1]
        }
    }

    return dp[m - 1][n - 1]
};

/* Climbing Stairs - You are climbing a staircase. It takes n steps to reach the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
 */
class Solution {
    fun climbStairs(n: Int): Int {
//  we will solve this using DP        
        if(n == 1){
            return 1
        }

        val dpArr = IntArray(n + 1)
//  one way to climb
        dpArr[1] = 1
//  two ways to climb
        dpArr[2] = 2

        for(counter in 3 until n + 1){
//  we need number of ways
//  either we can come from 2 steps below or 1 step below
            dpArr[counter] = dpArr[counter - 1] + dpArr[counter - 2]
        }

        return dpArr[n]
    }
}



Decode Ways - A message containing letters from A-Z can be encoded into numbers using the following mapping:

'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, "11106" can be mapped into:

"AAJF" with the grouping (1 1 10 6)
"KJF" with the grouping (11 10 6)
Note that the grouping (1 11 06) is invalid because "06" cannot be mapped into 'F' since "6" is different from "06".

Given a string s containing only digits, return the number of ways to decode it.

class Solution {
    fun numDecodings(s: String): Int {
        if(s[0] == '0'){
//  there is no mapping possible
            return 0
        }

        val dpArr = IntArray(s.length + 1)
        dpArr[0] = 1

        dpArr[1] = 1

        for(charCounter in 1 until s.length){
            if(s[charCounter] != '0'){
//  only taking the current char
                dpArr[charCounter + 1] = dpArr[charCounter]
            }

            val twoDigits = s.substring(charCounter - 1, charCounter + 1).toInt()
            if(twoDigits >= 10 && twoDigits <= 26){
//  other ways to decode if we take the last 2 chars
                dpArr[charCounter + 1] += dpArr[charCounter - 1]
            }
        }

        return dpArr[s.length]
    }
}



Longest Increasing Path in a Matrix - Given an m x n integers matrix, return the length of the longest increasing path in matrix.

From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).

var numRows = 0, numCols = 0

function longestIncreasingPath(matrix: number[][]): number {
    if(matrix.length == 0){
        return 0
    }

    numRows = matrix.length
    numCols = matrix[0].length

    var cache: number[][] = new Array(numRows).fill(0)
                                                .map(() => 
                                                    new Array(numCols).fill(0)
                                                );

    var pathAns = 0

    for(var row = 0; row < numRows; row++){
        for(var col = 0; col < numCols; col++){
//  find the path from all the points            
            pathAns = Math.max(pathAns, dfs(matrix, row, col, cache))
        }
    }

    return pathAns
};

function dfs(matrix: number[][], row: number, col: number, cache: number[][]): number{
    if(cache[row][col] != 0){
//  we already have visited this node        
        return cache[row][col]
    }

//  can move in these directions
    var directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]
    for(var dir of directions){
        var currRow = row + dir[0]
        var currCol = col + dir[1]

        if(currRow >= 0 && currCol >= 0 && currRow < numRows && currCol< numCols 
            && matrix[currRow][currCol] > matrix[row][col]){
//  find the longest path from this point                
            cache[row][col] = Math.max(cache[row][col],
                                    dfs(matrix, currRow, currCol, cache))
        }
    }

//  include the current point as well
    cache[row][col]++

    return cache[row][col]
}

/* Longest Increasing Subsequence - Given an integer array nums, return the length of the longest strictly increasing subsequence
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
const lengthOfLIS = (nums) => {
    // Initialize an array dp to store the length of LIS ending at each index
    const dp = Array(nums.length).fill(1);

    // Initialize a variable to store the maximum length of LIS
    let maxLength = 1;

    // Loop through each element in the array starting from index 1
    for (let i = 1; i < nums.length; i++) {
        // Nested loop to compare the current element with previous elements
        for (let j = 0; j < i; j++) {
            // Check if the current element is greater than the previous element
            if (nums[i] > nums[j]) {
                // Update the length of LIS ending at the current index
                dp[i] = Math.max(dp[i], dp[j] + 1);

                // Update the maximum length of LIS if needed
                maxLength = Math.max(maxLength, dp[i]);
            }
        }
    }

    // Return the overall maximum length of LIS
    return maxLength;
};

/* Maximum Profit in Job Scheduling - We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].

You're given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.

If you choose a job that ends at time X you will be able to start another job that starts at time X.
 */
/**
 * @param {number[]} startTime
 * @param {number[]} endTime
 * @param {number[]} profit
 * @return {number}
 */
const jobScheduling = (startTime, endTime, profit) => {
    // Create an array to store the jobs as [start time, end time, profit]
    const jobs = []
    for (let i = 0; i < startTime.length; i++) {
        jobs.push([startTime[i], endTime[i], profit[i]])
    }

    // Sort the jobs array based on start times in ascending order
    jobs.sort((a, b) => a[0] - b[0])

    // Get the total number of jobs
    const numJobs = jobs.length

    // Create an array to store the maximum profit for each job
    const profitArr = Array(numJobs)

    // Base case: Set the profit for the last job in the profitArr array
    profitArr[numJobs - 1] = jobs.at(-1)[2]

    // Iterate through the jobs array in reverse order to fill the profitArr array
    for (let i = numJobs - 2; i >= 0; i--) {
        const [start, end, profit] = jobs[i]
        let next = i + 1

        // Find the next job whose start time is greater than or equal to the current job's end time
        while (next < numJobs && jobs[next][0] < end) {
            next++
        }

        // Calculate the maximum profit for the current job by considering two cases:
        // 1. Include the current job and add its profit to the profit of the next compatible job
        // 2. Exclude the current job and consider the profit of the next job
        profitArr[i] = Math.max(profit + (next < numJobs ? profitArr[next] : 0),
            profitArr[i + 1])
    }

    // Return the maximum profit for scheduling jobs
    return profitArr[0]
};

/* Knight Dialer - Given an integer n, return how many distinct phone numbers of length n we can dial.

You are allowed to place the knight on any numeric cell initially and then you should perform n - 1 jumps to dial a number of length n. All jumps should be valid knight jumps.
 */
/**
 * @param {number} n
 * @return {number}
 */
const knightDialer = (n) => {

//  we will use dp to find the distinct phone numbers of length n 

    const mod = 10 ** 9 + 7

    //  map of starting position vs next positions
    const adjMap = {
        1: [6, 8],
        2: [7, 9],
        3: [4, 8],
        4: [3, 9, 0],
        5: [],
        6: [1, 7, 0],
        7: [2, 6],
        8: [1, 3],
        9: [2, 4],
        0: [4, 6],
    }

//  base case is length 1
    const dpArr = new Array(10).fill(1)

//  start from length 2 till n
    for(let i = 2; i <= n; i++){
        const newDpArr = new Array(10).fill(0)
        for(let j = 0; j < 10; j++){
            for(const nextDigit of adjMap[j]){
                newDpArr[j] = (newDpArr[j] + dpArr[nextDigit]) % mod 
            }
        }

        dpArr = newDpArr
    }

//  sum is the accumulator
    return dpArr.reduce((sum, val) => (sum + val) % mod, 0)
};

/* Unique Binary Search Trees - Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n.
 */
/**
 * @param {number} n
 * @return {number}
 */
const numTrees = (numNodes) => {
//  we will use DP for this

//  store number of unique BSTs for each number of nodes till numNodes
    const dpArr = new Array(numNodes + 1).fill(0)

//  only 1 BST for 0 nodes
    dpArr[0] = 1

//  find unique BSTs for number of nodes till numNodes
    for(let i = 1; i <= numNodes; i++){
//  for each possible root node, find unique BSTs for left and right subtrees        
        for(let j = 1; j <= i; j++){
//  number of unique BSTs for a given root is the product of number of unique BSTs for left and right subtrees
//  j is the root here            
            dpArr[i] += dpArr[j - 1] * dpArr[i - j]
        }
    }

    return dpArr[numNodes]
};



All possible full binary trees - Given an integer n, return a list of all possible full binary trees with n nodes. Each node of each tree in the answer must have Node.val == 0.

const allPossibleFBT = (n) => {
    // we will use DP to keep precomputed trees
    const memo = {}

    const createFBT = (size) => {
        //  FBT of one node can be created
        if (size === 1) {
            return [new TreeNode()]
        }
        //  can not form FBT with even number of nodes
        if (size % 2 == 0) {
            return []
        }
        //  we have already computed the result
        if (memo[size]) {
            return memo[size]
        }

        const trees = []

        // iterate over all possible odd numbers
        for (let left = 1; left < size; left += 2) {
            //  get all possible left subtress
            const leftTrees = createFBT(left)
            //  get all possible right subtress
            const rightTress = createFBT(size - left - 1)
            if (leftTrees && rightTress) {
                //  create combination of trees
                for (const l of leftTrees) {
                    for (r of rightTress) {
                        const root = new TreeNode(0, l, r)
                        //  track the root of all trees
                        trees.push(root)
                    }
                }
            }
        }

        //  keep for future use
        memo[size] = trees
        return trees
    }

    return createFBT(n)

};

/* Count sorted vowel strings - Given an integer n, return the number of strings of length n that consist only of vowels (a, e, i, o, u) and are lexicographically sorted.
 */
const countVowelStrings = (n) => {
    const memo = {}

    const backTrack = (index, strLength) => {
        const key = index + '_' + strLength

        if (memo[key]) {
            return memo[key]
        }
        if (strLength === n) {
            //  valid vowel string 
            return 1
        }

        if (strLength > n) {
            return 0
        }

        let count = 0
        for (let i = index; i < 5; i++) {
            count += backTrack(i, strLength + 1)
        }

        memo[key] = count

        return count
    }

    //  explore all possible combinations of vowels
    return backTrack(0, 0)
};



Count strictly increasing subarrays

const countIncreasingSubarraysDP = (arr) => {
    const n = arr.length;
    const dp = Array(n).fill(1); // Initialize dp array with all elements set to 1
    let count = 0;

    for (let i = 1; i < n; i++) {
        if (arr[i] > arr[i - 1]) {
            // If the current element is greater than the previous one,
            // update dp[i] with dp[i-1] + 1
            dp[i] = dp[i - 1] + 1;
        } else {
            // If the current element is not greater than the previous one,
            // reset dp[i] to 1
            dp[i] = 1;
        }

        // Add the length of the increasing subarray ending at index i to the count
        count += dp[i];
    }

    return count;
};

/* Count square submatrices with all 1s - Given a m * n matrix of ones and zeros, return how many square submatrices have all ones.
 */
const countSquares = (matrix) => {
    let count = 0

    //  dp array same as matrix
    const dp = new Array(matrix.length).fill().map(() => new Array(matrix[0].length).fill(0))

    //  visit each cell of the matrix
    for (let i = 0; i < matrix.length; i++) {
        for (let j = 0; j < matrix[0].length; j++) {
            if (matrix[i][j] === 0) {
                //  ignore 0s
            } else if (i === 0 || j === 0) {
                //  only one sub matrix possible for each [i, j]
                dp[i][j] = 1
                count += dp[i][j]
            } else {
                //  find the cell which has min submatrices in DP array
                const side = Math.min(dp[i - 1][j], Math.min(dp[i - 1][j - 1], dp[i][j - 1]))

                //  include this cell in the count
                dp[i][j] = side + 1

                //  count all submatrices
                count += dp[i][j]
            }
        }
    }

    return count
};

/* Paint house - You are given a matrix where each row represents a house, and each column represents the cost of painting that house with a particular color. The goal is to find the minimum cost to paint all the houses such that no two adjacent houses have the same color. Do it for 3 colors or 3 columns
*/

/**
 * @param {number[][]} costs - Cost matrix where costs[i][j] represents the cost of painting house i with color j.
 * @return {number} - Minimum cost to paint all houses.
 */
const minCost = (costs) => {
    if (costs.length === 0) {
        return 0;
    }

    const n = costs.length;
    const dp = Array.from({ length: n }, () => Array(3).fill(0));

    // base case - first row of the dp matrix - costs of painting the first house
    dp[0] = [...costs[0]];

    // Iterate through the houses starting from the second one
    for (let i = 1; i < n; i++) {
        //  painting ith house with the first color
        //  prev house can't be of same color
        dp[i][0] = costs[i][0] + Math.min(dp[i - 1][1], dp[i - 1][2]);

        //  painting ith house with the sec color
        //  prev house can't be of same color
        dp[i][1] = costs[i][1] + Math.min(dp[i - 1][0], dp[i - 1][2]);

        //  painting ith house with the 3rd color
        //  prev house can't be of same color
        dp[i][2] = costs[i][2] + Math.min(dp[i - 1][0], dp[i - 1][1]);
    }

    // The result is the minimum cost among the last row of the dp matrix
    return Math.min(...dp[n - 1]);
};