Longest Common Prefix - Write a function to find the longest common prefix string amongst an array of strings.
If there is no common prefix, return an empty string ""

class Solution {
    fun longestCommonPrefix(strs: Array<String>): String {
        
//         this problem can be solved using binary search approach. prefix means first few characters
        
        var LCP = ""
        
        if(strs.size > 0){
            var lengthOfMinStr = strs[0].length
            for(str in strs){
                if(str.length < lengthOfMinStr){
                    lengthOfMinStr = str.length
                }
            }
            
            if(lengthOfMinStr > 0){
                var lowIndex = 1
//              common prefix can't be longer than shortest string's length
                var highIndex = lengthOfMinStr

                
                while(lowIndex <= highIndex){
                    var middleIndex = (highIndex + lowIndex) / 2
                    if(isCommonPrefix(strs, middleIndex)){
//                     if we found the prefix on the left side then it means that there's more on the right side which can increase the length of LCP
                        lowIndex = middleIndex + 1
                    }else{
                        highIndex = middleIndex - 1
                    }
                }

//              middle index is the length of found common prefix
                LCP = strs[0].substring(0, (highIndex + lowIndex) / 2)
                
            }
        }
        
        return LCP
    }
    
    fun isCommonPrefix(strs : Array<String>, strLen : Int) : Boolean{
        val prefix = strs[0].substring(0, strLen)
        for(str in strs){
            if(!str.startsWith(prefix)){
                return false
            }
        }
        
        return true
    }
}

/* Single Element in a Sorted Array - You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.
Return the single element that appears only once.
Your solution must run in O(log n) time and O(1) space.
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
const singleNonDuplicate = (nums) => {
    //      insight is that ideally all the even indexes starting from 0 should be equal to the following odd indexed item
    //      when we cross an item which doesn't have a partner, all the items at odd indexes are equal to their predecessors at just before even indexes        

    let left = 0
    let right = nums.length - 1

    while (left < right) {
        let mid = Math.floor((left + right) / 2)
        if (mid % 2 === 1) {
            //  odd index
            mid -= 1
        }

        if (nums[mid] === nums[mid + 1]) {
            //  left part is fine
            left = mid + 2
        } else {
            right = mid
        }
    }

    return nums[left]
};

/* Find K Closest Elements - Given a sorted integer array arr, two integers k and x, return the k closest integers to x in the array. The result should also be sorted in ascending order.
 */
class Solution {
    fun findClosestElements(arr: IntArray, k: Int, x: Int): List<Int> {

//  we are given a sorted array and we can have max k integers which are closer to x. If we can find an index n whose value is closer to x but not of [n + k] then n is the starting index for finding k integers

        var left = 0
        var right = arr.size - k

        while(left < right){
            val mid = left + (right - left) / 2
            if(x - arr[mid] > arr[mid + k] - x){
//  x is closer to arr[mid + k] hence search in right subarray
                left = mid + 1
            }else{
                right = mid
            }
        }

        val resultList = mutableListOf<Int>()
        for(counter in left until left + k){
            resultList.add(arr[counter])
        }

        return resultList
    }
}


/* Capacity To Ship Packages Within D Days - A conveyor belt has packages that must be shipped from one port to another within given days.

The ith package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship.

Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within given days.
 */
/**
 * @param {number[]} weights
 * @param {number} days
 * @return {number}
 */
const shipWithinDays = (weights, days) => {
    //  we will use binary search in this

    let minCapacity = 0
    let maxCapacity = 0

    for (const weight of weights) {
        //  max of all weights
        minCapacity = Math.max(weight, minCapacity)

        //  total of all weights for 1 day coverage
        maxCapacity += weight
    }

    const isFeasible = (weights, capacity, days) => {
        let currentLoad = 0
        let daysNeeded = 1

        for (const weight of weights) {
            currentLoad += weight
            //  now load is more than the capacity
            if (currentLoad > capacity) {
                //  need another day for next load
                daysNeeded++
                //  prev weights were done in prev days
                currentLoad = weight
            }
        }

        return daysNeeded <= days
    }

    while (minCapacity < maxCapacity) {
        const mid = Math.floor((minCapacity + maxCapacity) / 2)
        if (isFeasible(weights, mid, days)) {
            //  solution might be on the left side
            maxCapacity = mid
        } else {
            minCapacity = mid + 1
        }
    }

    return minCapacity
};


Find Peak Element - A peak element is an element that is strictly greater than its neighbors.

Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.

You may imagine that nums[-1] = nums[n] = -âˆž. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.

You must write an algorithm that runs in O(log n) time.

class Solution {
    fun findPeakElement(nums: IntArray): Int {
        var leftCounter = 0
        var rightCounter = nums.size - 1

        while(leftCounter < rightCounter){
            val mid = (leftCounter + rightCounter) / 2
            if(nums[mid] > nums[mid + 1]){
//  there is a peak before mid
                rightCounter = mid
            }else{
                leftCounter = mid + 1
            }
        }

        return leftCounter
    }
}


/* Peak Index in a Mountain Array - Given a mountain array arr, return the index i such that arr[0] < arr[1] < ... < arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1].

You must solve it in O(log(arr.length)) time complexity.
 */
/**
 * @param {number[]} arr
 * @return {number}
 */
const peakIndexInMountainArray = (arr) => {
    //  cause of time constraints we have to use binary search

    let left = 0
    let right = arr.length

    while (left < right) {
        const mid = Math.floor((left + right) / 2)
        if (arr[mid + 1] > arr[mid]) {
            //  peak is on the right
            //  notice the condition of a peak
            left = mid + 1
        } else {
            right = mid
        }
    }

    return left
};

/* Find the Duplicate Number - Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.

There is only one repeated number in nums, return this repeated number.
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
const findDuplicate = (nums) => {
    //  use binary search

    let left = 0
    let right = nums.length - 1
    let duplicate = -1
    while (left <= right) {
        //  it's a numbered array
        const midNum = Math.floor((left + right) / 2)
        let smallNumsCount = 0
        for (const num of nums) {
            if (num <= midNum) {
                smallNumsCount++
            }
        }

        if (smallNumsCount > midNum) {
            //  duplicate is on the left side
            right = midNum - 1
            duplicate = midNum
        } else {
            //  duplicate is on the right side
            left = midNum + 1
        }
    }
    return duplicate
};

/* Koko Eating Bananas - Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.

Koko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.

Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return.

Return the minimum integer k such that she can eat all the bananas within h hours.
 */
class Solution {
    fun minEatingSpeed(piles: IntArray, h: Int): Int {
        
        var minSpeed = 1
        var maxSpeed = 1
        for(numBananas in piles){
            maxSpeed = maxOf(maxSpeed, numBananas)
//  going above maxSpeed doesn't make sense because in any hour only one pile can be eaten            
        }

        while(minSpeed < maxSpeed){
            val midSpeed = (minSpeed + maxSpeed) / 2
            var hoursSpent = 0

            for(numBananas in piles){
                hoursSpent += Math.ceil(numBananas * 1.0 / midSpeed).toInt()
//  1.5 hours means 2 hours                
            }

            if(hoursSpent <= h){
//  we are too fast                
                maxSpeed = midSpeed
            }else{
//  too slow                
                minSpeed = midSpeed + 1
            }
        }

        return maxSpeed
    }
}



Minimum Time to Complete Trips - You are given an array time where time[i] denotes the time taken by the ith bus to complete one trip.

Each bus can make multiple trips successively; that is, the next trip can start immediately after completing the current trip. Also, each bus operates independently; that is, the trips of one bus do not influence the trips of any other bus.

You are also given an integer totalTrips, which denotes the number of trips all buses should make in total. Return the minimum time required for all buses to complete at least totalTrips trips.

class Solution {
    fun minimumTime(times: IntArray, totalTrips: Int): Long {
        var maxTime = 0L
        for(time in times){
            maxTime = maxOf(maxTime, time.toLong())
        }

        var leftPointer = 1L
        var rightPointer = (maxTime * totalTrips).toLong()
//  max time to complete all trips

        while(leftPointer < rightPointer){
            val midPointer = (leftPointer + rightPointer) / 2

            if(timeEnough(times, midPointer, totalTrips)){
                rightPointer = midPointer
            }else{
                leftPointer = midPointer + 1
            }
        }

        return leftPointer.toLong()
    }

    fun timeEnough(times: IntArray, givenTime: Long, totalTrips: Int): Boolean{
        var actualTrips = 0L
        for(time in times){
//  how many trips can we do with given time            
            actualTrips += givenTime / time
        }

        return actualTrips >= totalTrips
    }
}



Search a 2D Matrix - You are given an m x n integer matrix matrix with the following two properties:

Each row is sorted in non-decreasing order.
The first integer of each row is greater than the last integer of the previous row.
Given an integer target, return true if target is in matrix or false otherwise.

class Solution {
    fun searchMatrix(matrix: Array<IntArray>, target: Int): Boolean {
//  this double array can be thought of as a single array with length  m * n 

        val numRows = matrix.size
        val numCols = matrix[0].size
        if(numRows == 0){
            return false
        }

        var left = 0
        var right = numRows * numCols - 1

        while(left <= right){
            val midPoint = (left + right) / 2

//  notice we are not using numRows            
            val midItem = matrix[midPoint / numCols][midPoint % numCols]

            if(midItem == target){
                return true
            }

            if(target < midItem){
                right = midPoint - 1
            }else{
                left = midPoint + 1
            }
        }

        return false
    }
}

/* Kth Smallest Element in a Sorted Matrix - Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the kth smallest element in the matrix.

Note that it is the kth smallest element in the sorted order, not the kth distinct element.

You must find a solution with a memory complexity better than O(n**2).
 */
/**
 * @param {number[][]} matrix
 * @param {number} k
 * @return {number}
 */
const kthSmallest = (matrix, k) => {
    //  we will use binary search

    let left = matrix[0][0]
    let right = matrix[matrix.length - 1][matrix.length - 1]

    while (left < right) {
        const mid = Math.floor((left + right) / 2)
        let numElements = 0
        let currCol = matrix.length - 1

        for (let currRow = 0; currRow < matrix.length; currRow++) {
            while (currCol >= 0 && matrix[currRow][currCol] > mid) {
                currCol--
            }
            //  these many elements are less than mid in this row
            numElements += currCol + 1
        }

        if (numElements < k) {
            //  we need more elements
            left = mid + 1
        } else {
            right = mid
        }
    }

    return left
};

// Median of two sorted arrays - Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.

// The overall run time complexity should be O(log (m+n)).

// Search in rotated array - Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.

// You must write an algorithm with O(log n) runtime complexity.

/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
const search = (nums, target) => {
    let low = 0
    let high = nums.length - 1

    while (low <= high) {
        let mid = Math.floor((low + high) / 2)
        if (nums[mid] === target) {
            return mid
        }

        if (nums[low] <= nums[mid]) {
            //  if left half is sorted
            if (nums[low] <= target && target <= nums[mid]) {
                high = mid - 1
            } else {
                // can discard the left half now cause it was sorted
                low = mid + 1
            }
        } else {
            if (nums[mid] <= target && target <= nums[high]) {
                low = mid + 1
            } else {
                // can discard the right half now cause it was sorted
                high = mid - 1
            }
        }
    }

    return -1
};



Smallest common number sorted rows - Given a matrix mat where every row is sorted in increasing order, return the smallest common element in all rows.

const smallestCommonElement = (mat) => {
    const rows = mat.length;
    const cols = mat[0].length;

    // Binary search function to check if a value is present in all rows
    const isPresentInAllRows = (value) => {
        for (let i = 0; i < rows; i++) {
            if (binarySearch(mat[i], value) === -1) {
                return false;
            }
        }
        return true;
    }

    // Binary search function to find the index of a value in a sorted array
    const binarySearch = (arr, target) => {
        let low = 0;
        let high = arr.length - 1;

        while (low <= high) {
            const mid = Math.floor((low + high) / 2);

            if (arr[mid] === target) {
                return mid;
            } else if (arr[mid] < target) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }

        return -1; // Element not found
    }

    // Find the minimum and maximum values in the first row
    let low = mat[0][0];
    let high = mat[0][cols - 1];

    // Binary search for the smallest common element
    while (low <= high) {
        const mid = Math.floor((low + high) / 2);

        if (isPresentInAllRows(mid)) {
            // If mid is present in all rows, search in the left half
            high = mid - 1;
        } else {
            // If mid is not present in all rows, search in the right half
            low = mid + 1;
        }
    }

    return low;
}



