/* Longest Common Prefix - Write a function to find the longest common prefix string amongst an array of strings.
If there is no common prefix, return an empty string ""
 */
class Solution {
    fun longestCommonPrefix(strs: Array<String>): String {
        
//         this problem can be solved using binary search approach. prefix means first few characters
        
        var LCP = ""
        
        if(strs.size > 0){
            var lengthOfMinStr = strs[0].length
            for(str in strs){
                if(str.length < lengthOfMinStr){
                    lengthOfMinStr = str.length
                }
            }
            
            if(lengthOfMinStr > 0){
                var lowIndex = 1
//              common prefix can't be longer than shortest string's length
                var highIndex = lengthOfMinStr

                
                while(lowIndex <= highIndex){
                    var middleIndex = (highIndex + lowIndex) / 2
                    if(isCommonPrefix(strs, middleIndex)){
//                     if we found the prefix on the left side then it means that there's more on the right side which can increase the length of LCP
                        lowIndex = middleIndex + 1
                    }else{
                        highIndex = middleIndex - 1
                    }
                }

//              middle index is the length of found common prefix
                LCP = strs[0].substring(0, (highIndex + lowIndex) / 2)
                
            }
        }
        
        return LCP
    }
    
    fun isCommonPrefix(strs : Array<String>, strLen : Int) : Boolean{
        val prefix = strs[0].substring(0, strLen)
        for(str in strs){
            if(!str.startsWith(prefix)){
                return false
            }
        }
        
        return true
    }
}

/* Single Element in a Sorted Array - You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.
Return the single element that appears only once.
Your solution must run in O(log n) time and O(1) space.
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
const singleNonDuplicate = (nums) => {
    //      insight is that ideally all the even indexes starting from 0 should be equal to the following odd indexed item
    //      when we cross an item which doesn't have a partner, all the items at odd indexes are equal to their predecessors at just before even indexes        

    let left = 0
    let right = nums.length - 1

    while (left < right) {
        let mid = Math.floor((left + right) / 2)
        if (mid % 2 === 1) {
            //  odd index
            mid -= 1
        }

        if (nums[mid] === nums[mid + 1]) {
            //  left part is fine
            left = mid + 2
        } else {
            right = mid
        }
    }

    return nums[left]
};

/* Find K Closest Elements - Given a sorted integer array arr, two integers k and x, return the k closest integers to x in the array. The result should also be sorted in ascending order.
 */
/**
 * @param {number[]} arr
 * @param {number} k
 * @param {number} x
 * @return {number[]}
 */
const findClosestElements = (arr, k, x) => {
    // Initialize left and right pointers for binary search
    let left = 0;
    let right = arr.length - k;

    // Perform binary search
    while (left < right) {
        // Calculate mid index
        const mid = Math.floor((right + left) / 2);

        // Check if x is closer to arr[mid + k]
        if (x - arr[mid] > arr[mid + k] - x) {
            // x is closer to arr[mid + k], search in the right subarray
            left = mid + 1;
        } else {
            // x is closer to arr[mid], search in the left subarray
            right = mid;
        }
    }

    // Create a list to store the result
    const resultList = [];

    // Add k elements starting from the left index to the result list
    for (let counter = left; counter < left + k; counter++) {
        resultList.push(arr[counter]);
    }

    // Return the result list
    return resultList;
};

/* Capacity To Ship Packages Within D Days - A conveyor belt has packages that must be shipped from one port to another within given days.

The ith package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship.

Return the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within given days.
 */
/**
 * @param {number[]} weights
 * @param {number} days
 * @return {number}
 */
const shipWithinDays = (weights, days) => {
    //  we will use binary search in this

    let minCapacity = 0
    let maxCapacity = 0

    for (const weight of weights) {
        //  max of all weights
        minCapacity = Math.max(weight, minCapacity)

        //  total of all weights for 1 day coverage
        maxCapacity += weight
    }

    const isFeasible = (weights, capacity, days) => {
        let currentLoad = 0
        let daysNeeded = 1

        for (const weight of weights) {
            currentLoad += weight
            //  now load is more than the capacity
            if (currentLoad > capacity) {
                //  need another day for next load
                daysNeeded++
                //  prev weights were done in prev days
                currentLoad = weight
            }
        }

        return daysNeeded <= days
    }

    while (minCapacity < maxCapacity) {
        const mid = Math.floor((minCapacity + maxCapacity) / 2)
        if (isFeasible(weights, mid, days)) {
            //  solution might be on the left side
            maxCapacity = mid
        } else {
            minCapacity = mid + 1
        }
    }

    return minCapacity
};

/* Peak Index in a Mountain Array - Given a mountain array arr, return the index i such that arr[0] < arr[1] < ... < arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1].

You must solve it in O(log(arr.length)) time complexity.
 */
/**
 * @param {number[]} arr
 * @return {number}
 */
const peakIndexInMountainArray = (arr) => {
    //  cause of time constraints we have to use binary search

    let left = 0
    let right = arr.length

    while (left < right) {
        const mid = Math.floor((left + right) / 2)
        if (arr[mid + 1] > arr[mid]) {
            //  peak is on the right
            //  notice the condition of a peak
            left = mid + 1
        } else {
            right = mid
        }
    }

    return left
};

/* Find the Duplicate Number - Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.

There is only one repeated number in nums, return this repeated number.
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
const findDuplicate = (nums) => {
    //  use binary search

    let left = 0
    let right = nums.length - 1
    let duplicate = -1
    while (left <= right) {
        //  it's a numbered array
        const midNum = Math.floor((left + right) / 2)
        let smallNumsCount = 0
        for (const num of nums) {
            if (num <= midNum) {
                smallNumsCount++
            }
        }

        if (smallNumsCount > midNum) {
            //  duplicate is on the left side
            right = midNum - 1
            duplicate = midNum
        } else {
            //  duplicate is on the right side
            left = midNum + 1
        }
    }
    return duplicate
};

/* Koko Eating Bananas - Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.

Koko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.

Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return.

Return the minimum integer k such that she can eat all the bananas within h hours.
 */
/**
 * @param {number[]} piles
 * @param {number} h
 * @return {number}
 */
const minEatingSpeed = (piles, h) => {

    //  per hour speeds
    let minSpeed = 1
    let maxSpeed = 1

    for (const num of piles) {
        //  max one pile is allowed in an hour
        maxSpeed = Math.max(num, maxSpeed)
    }

    while (minSpeed < maxSpeed) {
        const mid = Math.floor((minSpeed + maxSpeed) / 2)
        let hoursNeeded = 0
        for (const num of piles) {
            //  take the max of hours
            hoursNeeded += Math.ceil(num / mid)
        }

        if (hoursNeeded > h) {
            //  increase the speed
            minSpeed = mid + 1
        } else {
            maxSpeed = mid
        }
    }

    return minSpeed
};

/* Minimum Time to Complete Trips - You are given an array time where time[i] denotes the time taken by the ith bus to complete one trip.

Each bus can make multiple trips successively; that is, the next trip can start immediately after completing the current trip. Also, each bus operates independently; that is, the trips of one bus do not influence the trips of any other bus.

You are also given an integer totalTrips, which denotes the number of trips all buses should make in total. Return the minimum time required for all buses to complete at least totalTrips trips.
 */
class Solution {
    fun minimumTime(times: IntArray, totalTrips: Int): Long {
        var maxTime = 0L
        for(time in times){
            maxTime = maxOf(maxTime, time.toLong())
        }

        var leftPointer = 1L
        var rightPointer = (maxTime * totalTrips).toLong()
//  max time to complete all trips

        while(leftPointer < rightPointer){
            val midPointer = (leftPointer + rightPointer) / 2

            if(timeEnough(times, midPointer, totalTrips)){
                rightPointer = midPointer
            }else{
                leftPointer = midPointer + 1
            }
        }

        return leftPointer.toLong()
    }

    fun timeEnough(times: IntArray, givenTime: Long, totalTrips: Int): Boolean{
        var actualTrips = 0L
        for(time in times){
//  how many trips can we do with given time            
            actualTrips += givenTime / time
        }

        return actualTrips >= totalTrips
    }
}

/* Kth Smallest Element in a Sorted Matrix - Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the kth smallest element in the matrix.

Note that it is the kth smallest element in the sorted order, not the kth distinct element.

You must find a solution with a memory complexity better than O(n**2).
 */
/**
 * @param {number[][]} matrix
 * @param {number} k
 * @return {number}
 */
const kthSmallest = (matrix, k) => {
    //  we will use binary search

    let left = matrix[0][0]
    let right = matrix[matrix.length - 1][matrix.length - 1]

    while (left < right) {
        const mid = Math.floor((left + right) / 2)
        let numElements = 0
        let currCol = matrix.length - 1

        for (let currRow = 0; currRow < matrix.length; currRow++) {
            while (currCol >= 0 && matrix[currRow][currCol] > mid) {
                currCol--
            }
            //  these many elements are less than mid in this row
            numElements += currCol + 1
        }

        if (numElements < k) {
            //  we need more elements
            left = mid + 1
        } else {
            right = mid
        }
    }

    return left
};

// Median of two sorted arrays - Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.

// The overall run time complexity should be O(log (m+n)).

// Search in rotated array - Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.

// You must write an algorithm with O(log n) runtime complexity.

/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
const search = (nums, target) => {
    let low = 0
    let high = nums.length - 1

    while (low <= high) {
        let mid = Math.floor((low + high) / 2)
        if (nums[mid] === target) {
            return mid
        }

        if (nums[low] <= nums[mid]) {
            //  if left half is sorted
            if (nums[low] <= target && target <= nums[mid]) {
                high = mid - 1
            } else {
                // can discard the left half now cause it was sorted
                low = mid + 1
            }
        } else {
            if (nums[mid] <= target && target <= nums[high]) {
                low = mid + 1
            } else {
                // can discard the right half now cause it was sorted
                high = mid - 1
            }
        }
    }

    return -1
};



Smallest common number sorted rows - Given a matrix mat where every row is sorted in increasing order, return the smallest common element in all rows.

const smallestCommonElement = (mat) => {
    const rows = mat.length;
    const cols = mat[0].length;

    // Binary search function to check if a value is present in all rows
    const isPresentInAllRows = (value) => {
        for (let i = 0; i < rows; i++) {
            if (binarySearch(mat[i], value) === -1) {
                return false;
            }
        }
        return true;
    }

    // Binary search function to find the index of a value in a sorted array
    const binarySearch = (arr, target) => {
        let low = 0;
        let high = arr.length - 1;

        while (low <= high) {
            const mid = Math.floor((low + high) / 2);

            if (arr[mid] === target) {
                return mid;
            } else if (arr[mid] < target) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }

        return -1; // Element not found
    }

    // Find the minimum and maximum values in the first row
    let low = mat[0][0];
    let high = mat[0][cols - 1];

    // Binary search for the smallest common element
    while (low <= high) {
        const mid = Math.floor((low + high) / 2);

        if (isPresentInAllRows(mid)) {
            // If mid is present in all rows, search in the left half
            high = mid - 1;
        } else {
            // If mid is not present in all rows, search in the right half
            low = mid + 1;
        }
    }

    return low;
}

/* Kth Smallest Subarray Sum - Given an integer array nums of length n and an integer k, return the kth smallest subarray sum.
 */
const kthSmallestSubarraySum = (nums, k) => {
  // Helper function to count the number of subarrays with sum less than or equal to maxSum
  const countSubarrays = (maxSum) => {
    let count = 0;
    let sum = 0;
    let left = 0;

    for (let right = 0; right < nums.length; right++) {
      sum += nums[right];

      // Shrink the subarray from the left until the sum is less than or equal to maxSum
      while (sum > maxSum) {
        sum -= nums[left];
        left++;
      }

      // Add the count of subarrays with sum less than or equal to maxSum
      count += right - left + 1;
    }

    return count;
  }

  // Sort the array to use binary search
  nums.sort((a, b) => a - b);

  let low = nums[0];
  let high = nums.reduce((a, b) => a + b, 0); // Sum of all elements in the array

  // Binary search to find the Kth smallest subarray sum
  while (low < high) {
    const mid = Math.floor((low + high) / 2);
    const count = countSubarrays(mid);

    // Adjust the search space based on the count
    if (count < k) {
      // If the count is less than K, increase the lower bound
      low = mid + 1;
    } else {
      // If the count is greater than or equal to K, decrease the upper bound
      high = mid;
    }
  }

  // The final low value is the Kth smallest subarray sum
  return low;
}

/* Cutting Ribbons 
- You're given an array ribbons where ribbons[i] represents the length of the i-th ribbon.
- You're also given an integer k.
- You can cut ribbons into smaller segments of positive integer lengths, or leave them intact.
- Your goal is to obtain k ribbons of all the same positive integer length.
- You can discard excess ribbon material.
Return the maximum possible positive integer length of those k ribbons, or 0 if it's not achievable.
 */
 /**
 * @param {number[]} ribbons - Array of ribbon lengths
 * @param {number} k - Target number of segments
 * @return {number} - Maximum valid ribbon length
 */
const maxLength = (ribbons, k) => {
    // Function to check if it's possible to cut ribbons into segments with a given length
    const canCut = (length) => {
        let count = 0;
        for (const ribbon of ribbons) {
            // Count how many segments can be obtained from each ribbon with the given length
            count += Math.floor(ribbon / length);
        }
        // Check if the total count of segments is greater than or equal to the target (k)
        return count >= k;
    };

    // Binary search to find the maximum valid ribbon length
    let left = 1; // The minimum possible ribbon length
    let right = Math.max(...ribbons); // The maximum possible ribbon length

    while (left <= right) {
        const mid = Math.floor((left + right) / 2); // Calculate the middle length

        if (canCut(mid)) {
            // If it's possible to cut the ribbons with the current length, search in the right half
            left = mid + 1;
        } else {
            // If it's not possible to cut the ribbons with the current length, search in the left half
            right = mid - 1;
        }
    }

    // The result is right since we want to maximize the ribbon length
    return right;
};