Fruit Into Baskets - You are visiting a farm that has a single row of fruit trees arranged from left to right.The trees are represented by an integer array fruits where fruits[i] is the type of fruit the ith tree produces.

You want to collect as much fruit as possible.However, the owner has some strict rules that you must follow:

You only have two baskets, and each basket can only hold a single type of fruit.There is no limit on the amount of fruit each basket can hold.
Starting from any tree of your choice, you must pick exactly one fruit from every tree(including the start tree) while moving to the right.The picked fruits must fit in one of your baskets.
Once you reach a tree with fruit that cannot fit in your baskets, you must stop.
Given the integer array fruits, return the maximum number of fruits you can pick.

class Solution {
    fun totalFruit(fruits: IntArray): Int {
        //  we can choose max of 2 groups of fruits and can have unlimited fruits in each group

        var left = 0
        var right = 0;
        var totalNumFruits = 0;

        //  we will maintain the number of fruits in each group         
        var fruitsMap = mutableMapOf < Int, Int> ()

        for (right in 0 until fruits.size) {
            //  increase the number of fruits in second group as we move forward            
            fruitsMap.put(fruits[right],
                fruitsMap.getOrDefault(fruits[right], 0) + 1)
            totalNumFruits++;

            //  check if we found a new group
            if (fruitsMap.size > 2) {
                //  we have to maintain number of fruit groups to 2
                fruitsMap.put(fruits[left],
                    fruitsMap.getOrDefault(fruits[left], 0) - 1)
                totalNumFruits--;
                if (fruitsMap.getOrDefault(fruits[left], 0) == 0) {
                    //  remove this group of fruits                    
                    fruitsMap.remove(fruits[left])
                }
                //  move the left index of subarray as we removed one fruit group
                left++;
            }
        }

        //  max length of subarray as per definition = right - left

        return totalNumFruits
    }
}

/* Longest Subarray of 1's After Deleting One Element - Given a binary array nums, you should delete one element from it.

Return the size of the longest non-empty subarray containing only 1's in the resulting array. Return 0 if there is no such subarray.
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
const longestSubarray = (nums) => {
    //  solve this using two pointers

    let left = 0
    let right = 0
    let zeroCount = 0

    let maxLength = 0

    //  move from left to right
    while (right < nums.length) {
        if (nums[right] == 0) {
            //  track num 0s
            zeroCount++
        }

        //  keep max one 0
        while (zeroCount > 1) {
            if (nums[left] === 0) {
                zeroCount--
            }
            //  shrink the window
            left++
        }

        //  record window size
        maxLength = Math.max(maxLength, right - left)

        right++
    }

    return maxLength
};

/* Find All Anagrams in a String - Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order.
 */
/**
 * @param {string} s
 * @param {string} p
 * @return {number[]}
 */
const findAnagrams = (s, p) => {
    // Record characters and count in the small string
    const targetCharArray = Array(26).fill(0);

    // Count the frequency of each character in the pattern 'p'
    for (const char of p) {
        targetCharArray[char.charCodeAt(0) - 'a'.charCodeAt(0)]++;
    }

    // Initialize an array to represent the sliding window's character count
    const windowArr = Array(26).fill(0);

    // Initialize pointers for the sliding window
    let left = 0;
    let right = 0;

    // Array to store the starting indices of anagrams
    const resultList = [];

    // Helper function to check if two arrays are equal
    const arraysAreEqual = (arr1, arr2) => {
        for (let i = 0; i < arr1.length; i++) {
            if (arr1[i] !== arr2[i]) {
                return false;
            }
        }
        return true;
    };

    // Iterate through the characters in the string 's'
    while (right < s.length) {
        // Add the current character to the sliding window
        const currChar = s[right];
        windowArr[currChar.charCodeAt(0) - 'a'.charCodeAt(0)]++;

        // Check if the window size is equal to the length of the pattern 'p'
        if (right - left + 1 === p.length) {
            // Check if the current window is an anagram
            if (arraysAreEqual(windowArr, targetCharArray)) {
                // Found an anagram, push the starting index to the result array
                resultList.push(left);
            }

            // Reduce the count of the leftmost character to move the window forward
            const charToDelete = s[left];
            windowArr[charToDelete.charCodeAt(0) - 'a'.charCodeAt(0)]--;
            left++;
        }

        // Move the right pointer to expand the window
        right++;
    }

    // Return the array of starting indices of anagrams
    return resultList;
};

/* Longest substring without repeating characters - Given a string s, find the length of the longest substring without repeating characters.
 */
/**
 * @param {string} s
 * @return {number}
 */
const lengthOfLongestSubstring = (s) => {
    let maxLength = 0
    const charIndexMap = {}
    let subStringLeftIndex = 0

    for (j = 0; j < s.length; j++) {
        const currChar = s[j]
        if (charIndexMap[currChar] !== undefined) {
            //  found a repeat character
            subStringLeftIndex = Math.max(charIndexMap[currChar] + 1, subStringLeftIndex)
        }

        charIndexMap[currChar] = j

        maxLength = Math.max(maxLength, j - subStringLeftIndex + 1)
    }

    return maxLength
};

/* Count Subarrays With Fixed Bounds - You are given an integer array nums and two integers minK and maxK.

A fixed-bound subarray of nums is a subarray that satisfies the following conditions:
The minimum value in the subarray is equal to minK.
The maximum value in the subarray is equal to maxK.
Return the number of fixed-bound subarrays.

A subarray is a contiguous part of an array.
 */
/**
 * @param {number[]} nums
 * @param {number} minK
 * @param {number} maxK
 * @return {number}
 */
const countSubarrays = (nums, minK, maxK) => {
    //  we will take sliding window approach

    let left = -1
    let right = -1

    //  most recent index out of range    
    let outOfRangeIndex = -1

    let numSubArrays = 0

    for (let i = 0; i < nums.length; i++) {
        //  update out of range index        
        if (nums[i] < minK || nums[i] > maxK) {
            outOfRangeIndex = i
        }

        //  update recent positions if any
        if (nums[i] === minK) {
            left = i
        }
        if (nums[i] === maxK) {
            right = i
        }

        //  number of subarrays is number of elements between outOfRangeBound and smaller of two indices
        numSubArrays += Math.max(0, Math.min(right, left) - outOfRangeIndex)
    }

    return numSubArrays
};

/* Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold - Given an array of integers arr and two integers k and threshold, return the number of sub-arrays of size k and average greater than or equal to threshold.
 */
/**
 * @param {number[]} arr
 * @param {number} k
 * @param {number} threshold
 * @return {number}
 */
const numOfSubarrays = (arr, k, threshold) => {
    let count = 0
    let sum = 0

    //  find the sum of the first k length subarray
    for (let i = 0; i < k; i++) {
        sum += arr[i]
    }

    //  continue for further sub arrays
    for (let i = k; i <= arr.length; i++) {

        //  avg of current subarray
        const avg = sum / k

        if (avg >= threshold) {
            count++
        }

        //  remove the first element of this subarray
        sum -= arr[i - k]
        //  add the next
        sum += arr[i]
    }

    return count
};



Find k length substrings without repeat characters -

/**
 * @param {string} s
 * @param {number} k
 * @return {string[]}
 */
const findSubstrings = (s, k) => {
    const result = [];

    for (let i = 0; i <= s.length - k; i++) {
        const substring = s.substring(i, i + k);

        if (!hasRepeatCharacters(substring)) {
            result.push(substring);
        }
    }

    return result;
};

/**
 * Helper function to check if a string has repeat characters.
 * @param {string} str
 * @return {boolean}
 */
const hasRepeatCharacters = (str) => {
    const set = new Set();

    for (let char of str) {
        if (set.has(char)) {
            return true; // Repeat character found
        }
        set.add(char);
    }

    return false; // No repeat characters
}

/* 
Maximize the confusion in exam - A teacher is writing a test with n true/false questions, with 'T' denoting true and 'F' denoting false. He wants to confuse the students by maximizing the number of consecutive questions with the same answer (multiple trues or multiple falses in a row).

You are given a string answerKey, where answerKey[i] is the original answer to the ith question. In addition, you are given an integer k, the maximum number of times you may perform the following operation:

Change the answer key for any question to 'T' or 'F' (i.e., set answerKey[i] to 'T' or 'F').
Return the maximum number of consecutive 'T's or 'F's in the answer key after performing the operation at most k times.
 */

/**
 * @param {string} answerKey
 * @param {number} k
 * @return {number}
 */
const maxConsecutiveAnswers = (answerKey, k) => {
    const maxConsequtive = (char) => {
        let left = 0, charCount = 0, max = 0
        //  Iterating over the answer key using right pointer
        for (let right = 0; right < answerKey.length; right++) {
            //  currentChar is the char that should be atmost k times
            if (answerKey[right] === char) {
                charCount++
            }

            //  we have more than k chars 
            //  we have to shrink the window
            while (charCount > k) {
                if (answerKey[left] === char) {
                    charCount--
                }
                left++
            }
            //  Current window has atmost k chars
            max = Math.max(max, right - left + 1)
        }
        return max
    }

    return Math.max(maxConsequtive('T'), maxConsequtive('F'))
};

/* Max consecutive Ones - Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.
 */

/**
* @param {number[]} nums
* @param {number} k
* @return {number}
*/
const longestOnes = (nums, k) => {
    //  use sliding window

    let left = 0, right = 0

    while (right < nums.length) {
        if (nums[right] === 0) {
            //  found a zero hence a flip is used
            k--
        }
        if (k < 0) {
            //  window has to be shrinked from left
            if (nums[left] === 0) {
                //  gained one flip
                k++
            }
            left++
        }
        right++
    }

    return right - left
};

/* Sequential Digits - An integer has sequential digits if and only if each digit in the number is one more than the previous digit.

Return a sorted list of all the integers in the range [low, high] inclusive that have sequential digits.
 */

/**
 * @param {number} low
 * @param {number} high
 * @return {number[]}
 */
const sequentialDigits = (low, high) => {
    //  use sliding window

    const digits = '123456789'
    const ans = []

    const minLen = low.toString().length
    const maxLen = high.toString().length

    for (let size = minLen; size <= maxLen; ++size) {
        for (let i = 0; i + size <= digits.length; ++i) {
            const num = parseInt(digits.substring(i, i + size))

            if (num >= low && num <= high) {
                ans.push(num)
            }
        }
    }

    return ans
};

/* Min recolors to get k consectuive black blocks - You are given a 0-indexed string blocks of length n, where blocks[i] is either 'W' or 'B', representing the color of the ith block. The characters 'W' and 'B' denote the colors white and black, respectively.

You are also given an integer k, which is the desired number of consecutive black blocks.

In one operation, you can recolor a white block such that it becomes a black block.

Return the minimum number of operations needed such that there is at least one occurrence of k consecutive black blocks.
 */

/**
 * @param {string} blocks
 * @param {number} k
 * @return {number}
 */
const minimumRecolors = (blocks, k) => {
    //  use sliding window

    let min = Infinity
    let start = 0
    let currMin = 0
    for (let end = 0; end < blocks.length; end++) {
        if (blocks[end] === 'W') {
            currMin++
        }
        if (end - start + 1 === k) {
            //  found the window
            min = Math.min(currMin, min)

            //  shrink window from left
            if (blocks[start++] === 'W') {
                //  remove the count
                currMin--
            }
        }
    }

    return min
};

/* Max num of vowels in a substring of given length - Given a string s and an integer k, return the maximum number of vowel letters in any substring of s with length k.
 */

/**
* @param {string} s
* @param {number} k
* @return {number}
*/
const maxVowels = (s, k) => {
    let maxCount = 0, count = 0;
    const vowel = ['a', "e", "i", "o", "u"]
    for (let i = 0; i < s.length; i++) {
        if (vowel.includes(s[i])) {
            //  found a vowel
            count++
        }

        if (i >= k && vowel.includes(s[i - k])) {
            //  removing the vowel from start of substring
            count--
        }

        //  max possible number
        if (count == k) {
            return k;
        }

        //  update max
        if (maxCount < count) {
            maxCount = count
        }
    }
    return maxCount
};

/* Longest repeating character replacement - You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.

Return the length of the longest substring containing the same letter you can get after performing the above operations.
 */

/**
 * @param {string} s
 * @param {number} k
 * @return {number}
 */
const characterReplacement = (s, k) => {
    // Initialize left and right pointers for the sliding window
    let left = 0;
    let right = 0;

    // Initialize the maximum count of a character in the current window
    let maxCharCount = 0;

    // Create a dictionary to keep track of character frequencies in the current window
    const visited = {};

    // Iterate through the string using the sliding window
    while (right < s.length) {
        // Current character in the window
        const char = s[right];

        // Update the frequency of the current character in the visited dictionary
        visited[char] = visited[char] ? visited[char] + 1 : 1;

        // Update the maximum count of a character in the current window
        if (visited[char] > maxCharCount) {
            maxCharCount = visited[char];
        }

        // Check if the length of the window - maximum character count is greater than 'k'
        //  we need to have a single char in the window
        if (right - left + 1 - maxCharCount > k) {
            // Move the left pointer to shrink the window
            visited[s[left]]--;  // Reduce the frequency of the character at the left end
            left++;
        }

        // Expand the window to the right
        right++;
    }

    // The length of the longest substring with at most 'k' replacements
    return right - left;
};