Fruit Into Baskets - You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array fruits where fruits[i] is the type of fruit the ith tree produces.

You want to collect as much fruit as possible. However, the owner has some strict rules that you must follow:

You only have two baskets, and each basket can only hold a single type of fruit. There is no limit on the amount of fruit each basket can hold.
Starting from any tree of your choice, you must pick exactly one fruit from every tree (including the start tree) while moving to the right. The picked fruits must fit in one of your baskets.
Once you reach a tree with fruit that cannot fit in your baskets, you must stop.
Given the integer array fruits, return the maximum number of fruits you can pick.

class Solution {
    fun totalFruit(fruits: IntArray): Int {
//  we can choose max of 2 groups of fruits and can have unlimited fruits in each group

        var left = 0
        var right = 0;
        var totalNumFruits = 0;

//  we will maintain the number of fruits in each group         
        var fruitsMap = mutableMapOf<Int, Int>()

        for(right in 0 until fruits.size){
//  increase the number of fruits in second group as we move forward            
            fruitsMap.put(fruits[right], 
                fruitsMap.getOrDefault(fruits[right], 0) + 1)
            totalNumFruits++;

//  check if we found a new group
            if(fruitsMap.size > 2){
//  we have to maintain number of fruit groups to 2
                fruitsMap.put(fruits[left], 
                    fruitsMap.getOrDefault(fruits[left], 0) - 1)   
                totalNumFruits--;
                if(fruitsMap.getOrDefault(fruits[left], 0) == 0){
//  remove this group of fruits                    
                    fruitsMap.remove(fruits[left])
                }
//  move the left index of subarray as we removed one fruit group
                left++;
            }            
        }

//  max length of subarray as per definition = right - left
        
        return totalNumFruits
    }
}

/* Longest Subarray of 1's After Deleting One Element - Given a binary array nums, you should delete one element from it.

Return the size of the longest non-empty subarray containing only 1's in the resulting array. Return 0 if there is no such subarray.
 */
/**
 * @param {number[]} nums
 * @return {number}
 */
const longestSubarray = (nums) => {
    //  solve this using two pointers

    let left = 0
    let right = 0
    let zeroCount = 0

    let maxLength = 0

    //  move from left to right
    while(right < nums.length){
        if(nums[right] == 0){
            //  track num 0s
            zeroCount++
        }

        //  keep max one 0
        while(zeroCount > 1){
            if(nums[left] === 0){
                zeroCount--
            }
            //  shrink the window
            left++
        }

        //  record window size
        maxLength = Math.max(maxLength, right - left)

        right++
    }

    return maxLength
};

/* Find All Anagrams in a String - Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order.
 */
class Solution {
    fun findAnagrams(s: String, p: String): List<Int> {
        
//  record characters and count in the small string        
        val targetCharArray = IntArray(26)
        for(char in p){
            targetCharArray[char - 'a']++
        }

        val windowArr = IntArray(26)
        var left = 0
        var right = 0

        val resultList = mutableListOf<Int>()

        while(right < s.length){
            val currChar = s[right]
            windowArr[currChar - 'a']++

            if(right - left + 1 == p.length){
//  could be an anagram now                
                if(windowArr.contentEquals(targetCharArray)){
//  found an anagram
                    resultList.add(left) 
//  only need the left index                                       
                }

//  need to reduce count of the left most character to move forward
                val charToDelete = s[left]
                windowArr[charToDelete - 'a']--
                left++
            }
            right++
        }
        return resultList
    }
}



Longest substring without repeating characters - Given a string s, find the length of the longest substring without repeating characters.

/**
 * @param {string} s
 * @return {number}
 */
const lengthOfLongestSubstring = (s) => {
    let maxLength = 0
    const charIndexMap = {}
    let subStringLeftIndex = 0
    
    for (j = 0; j < s.length; j++) {
        const currChar = s[j]
        if (charIndexMap[currChar] !== undefined) {
            //  found a repeat character
            subStringLeftIndex = Math.max(charIndexMap[currChar] + 1, subStringLeftIndex)
        }

        charIndexMap[currChar] = j

        maxLength = Math.max(maxLength, j - subStringLeftIndex + 1)
    }

    return maxLength
};



Kth Smallest Subarray Sum - Given an integer array nums of length n and an integer k, return the kth smallest subarray sum.

class Solution {
    fun kthSmallestSubarraySum(nums: IntArray, k: Int): Int {
        var leftPointer = Int.MAX_VALUE
        var rightPointer = 0
        for(num in nums){
            leftPointer = minOf(num, leftPointer)
            rightPointer += num
        }
//  our smalled sub array sum is the left pointer and max sub array sum is the right pointer
//  kth is somewhere in between

        while(leftPointer <= rightPointer){
            val midSum = (leftPointer + rightPointer) / 2

//  how many sub arrays we have before midSum
            if(numSubArrays(nums, midSum) >= k){
                rightPointer = midSum - 1
            }else{
                leftPointer = midSum + 1
            }
        }
        return leftPointer

    }

    fun numSubArrays(nums: IntArray, targetSum: Int): Int{
        var subArrayCount = 0
        var currSum = 0
        var leftPointer = 0

        for(rightPointer in 0 until nums.size){
            currSum += nums[rightPointer]
            while(currSum > targetSum){
//  move the leftPointer to keep currSum below
                currSum -= nums[leftPointer]
                leftPointer++
            }
//  notice we increase count for each rightPointer            
            subArrayCount += rightPointer - leftPointer + 1
        }

        return subArrayCount
    }
}

/* Count Subarrays With Fixed Bounds - You are given an integer array nums and two integers minK and maxK.

A fixed-bound subarray of nums is a subarray that satisfies the following conditions:
The minimum value in the subarray is equal to minK.
The maximum value in the subarray is equal to maxK.
Return the number of fixed-bound subarrays.

A subarray is a contiguous part of an array.
 */
/**
 * @param {number[]} nums
 * @param {number} minK
 * @param {number} maxK
 * @return {number}
 */
const countSubarrays = (nums, minK, maxK) => {
    //  we will take sliding window approach

    let left = -1
    let right = -1

    //  most recent index out of range    
    let outOfRangeIndex = -1

    let numSubArrays = 0

    for (let i = 0; i < nums.length; i++) {
        //  update out of range index        
        if (nums[i] < minK || nums[i] > maxK) {
            outOfRangeIndex = i
        }

        //  update recent positions if any
        if (nums[i] === minK) {
            left = i
        }
        if (nums[i] === maxK) {
            right = i
        }

        //  number of subarrays is number of elements between outOfRangeBound and smaller of two indices
        numSubArrays += Math.max(0, Math.min(right, left) - outOfRangeIndex)
    }

    return numSubArrays
};

/* Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold - Given an array of integers arr and two integers k and threshold, return the number of sub-arrays of size k and average greater than or equal to threshold.
 */
/**
 * @param {number[]} arr
 * @param {number} k
 * @param {number} threshold
 * @return {number}
 */
const numOfSubarrays = (arr, k, threshold) => {
    let count = 0
    let sum = 0

    //  find the sum of the first k length subarray
    for (let i = 0; i < k; i++) {
        sum += arr[i]
    }

    //  continue for further sub arrays
    for (let i = k; i <= arr.length; i++) {

        //  avg of current subarray
        const avg = sum / k

        if (avg >= threshold) {
            count++
        }

        //  remove the first element of this subarray
        sum -= arr[i - k]
        //  add the next
        sum += arr[i]
    }

    return count
};



Find k length substrings without repeat characters - 

/**
 * @param {string} s
 * @param {number} k
 * @return {string[]}
 */
const findSubstrings =(s, k) => {
    const result = [];
    
    for (let i = 0; i <= s.length - k; i++) {
        const substring = s.substring(i, i + k);
        
        if (!hasRepeatCharacters(substring)) {
            result.push(substring);
        }
    }
    
    return result;
};

/**
 * Helper function to check if a string has repeat characters.
 * @param {string} str
 * @return {boolean}
 */
const hasRepeatCharacters = (str) => {
    const set = new Set();
    
    for (let char of str) {
        if (set.has(char)) {
            return true; // Repeat character found
        }
        set.add(char);
    }
    
    return false; // No repeat characters
}

/* 
Maximize the confusion in exam - A teacher is writing a test with n true/false questions, with 'T' denoting true and 'F' denoting false. He wants to confuse the students by maximizing the number of consecutive questions with the same answer (multiple trues or multiple falses in a row).

You are given a string answerKey, where answerKey[i] is the original answer to the ith question. In addition, you are given an integer k, the maximum number of times you may perform the following operation:

Change the answer key for any question to 'T' or 'F' (i.e., set answerKey[i] to 'T' or 'F').
Return the maximum number of consecutive 'T's or 'F's in the answer key after performing the operation at most k times.
 */

/**
 * @param {string} answerKey
 * @param {number} k
 * @return {number}
 */
const maxConsecutiveAnswers = (answerKey, k) => {
    const maxConsequtive = (char) => {
        let left = 0, charCount = 0, max = 0
        //  Iterating over the answer key using right pointer
        for (let right = 0; right < answerKey.length; right++) {
            //  currentChar is the char that should be atmost k times
            if (answerKey[right] === char) {
                charCount++
            }

            //  we have more than k chars 
            //  we have to shrink the window
            while (charCount > k) {
                if (answerKey[left] === char) {
                    charCount--
                }
                left++
            }
            //  Current window has atmost k chars
            max = Math.max(max, right - left + 1)
        }
        return max
    }

    return Math.max(maxConsequtive('T'), maxConsequtive('F'))
};

/* Max consecutive Ones - Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.
 */

 /**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
const longestOnes = (nums, k) => {
    //  use sliding window

    let left = 0, right = 0

    while (right < nums.length) {
        if (nums[right] === 0) {
            //  found a zero hence a flip is used
            k--
        }
        if (k < 0) {
            //  window has to be shrinked from left
            if (nums[left] === 0) {
                //  gained one flip
                k++
            }
            left++
        }
        right++
    }

    return right - left
};

/* Sequential Digits - An integer has sequential digits if and only if each digit in the number is one more than the previous digit.

Return a sorted list of all the integers in the range [low, high] inclusive that have sequential digits.
 */

/**
 * @param {number} low
 * @param {number} high
 * @return {number[]}
 */
const sequentialDigits = (low, high) => {
    //  use sliding window

    const digits = '123456789'
    const ans = []

    const minLen = low.toString().length
    const maxLen = high.toString().length

    for (let size = minLen; size <= maxLen; ++size) {
        for (let i = 0; i + size <= digits.length; ++i) {
            const num = parseInt(digits.substring(i, i + size))

            if (num >= low && num <= high) {
                ans.push(num)
            }
        }
    }

    return ans
};

/* Min recolors to get k consectuive black blocks - You are given a 0-indexed string blocks of length n, where blocks[i] is either 'W' or 'B', representing the color of the ith block. The characters 'W' and 'B' denote the colors white and black, respectively.

You are also given an integer k, which is the desired number of consecutive black blocks.

In one operation, you can recolor a white block such that it becomes a black block.

Return the minimum number of operations needed such that there is at least one occurrence of k consecutive black blocks.
 */

/**
 * @param {string} blocks
 * @param {number} k
 * @return {number}
 */
const minimumRecolors = (blocks, k) => {
    //  use sliding window

    let min = Infinity
    let start = 0
    let currMin = 0
    for (let end = 0; end < blocks.length; end++) {
        if (blocks[end] === 'W') {
            currMin++
        }
        if (end - start + 1 === k) {
            //  found the window
            min = Math.min(currMin, min)

            //  shrink window from left
            if (blocks[start++] === 'W') {
                //  remove the count
                currMin--
            }
        }
    }

    return min
};