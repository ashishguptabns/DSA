/* Product of array except self - Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].

The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.

You must write an algorithm that runs in O(n) time and without using the division operation.
 */

/**
 * @param {number[]} nums
 * @return {number[]}
 */
const productExceptSelf = (nums) => {
    const size = nums.length
    const res = new Array(size).fill(1)

    let leftProduct = 1
    let rightProduct = 1

    for (let i = 0; i < size; i++) {
        //  put the product of elements on the left
        res[i] *= leftProduct
        //  update the product
        leftProduct *= nums[i]
    }

    for (let i = size - 1; i >= 0; i--) {
        //  put the product of elements on the right
        res[i] *= rightProduct
        //  update the product
        rightProduct *= nums[i]
    }

    return res
};

/* Minimum Time to Make Rope Colorful - Alice has n balloons arranged on a rope. You are given a 0-indexed string color where colors[i] is the color of the ith balloon.

Alice wants the rope to be colorful. She does not want two consecutive balloons to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it colorful. You are given a 0-indexed integer array neededTime where neededTime[i] is the time (in seconds) that Bob needs to remove the ith balloon from the rope.

Return the minimum time Bob needs to make the rope colorful.
 */

/**
 * @param {string} colors
 * @param {number[]} neededTime
 * @return {number}
 */
const minCost = (colors, neededTime) => {

    let time = 0

    //  start from 2nd balloon
    for (let i = 1; i < colors.length; i++) {
        //  found the consecutive same color balloons
        if (colors[i] === colors[i - 1]) {
            if (neededTime[i] > neededTime[i - 1]) {
                time += neededTime[i - 1]
            } else {
                time += neededTime[i]
            }
        }
    }

    return time
};

/* 
Sum of subarray ranges - You are given an integer array nums. The range of a subarray of nums is the difference between the largest and smallest element in the subarray.

Return the sum of all subarray ranges of nums.

A subarray is a contiguous non-empty sequence of elements within an array.
 */

/**
 * @param {number[]} nums
 * @return {number}
 */
const subArrayRanges = (nums) => {
    let sum = 0
    for (let i = 0; i < nums.length; i++) {
        //  min max for subarrays starting with i
        let min = nums[i]
        let max = nums[i]
        for (let j = i + 1; j < nums.length; j++) {
            //  min max for subarrays ending with j
            min = Math.min(min, nums[j])
            max = Math.max(max, nums[j])

            sum += max - min
        }
    }

    return sum
};